{
    "$schema": "../../schemas/Locale.json",
    "language": "en",
    "wordplay": "Wordplay",
    "term": {
        "store": "bind",
        "code": "evaluate",
        "decide": "decide",
        "project": "performance",
        "source": "source",
        "input": "input",
        "output": "output",
        "act": "act",
        "scene": "scene",
        "phrase": "phrase",
        "group": "group",
        "verse": "verse",
        "type": "type",
        "start": "start",
        "entered": "new",
        "changed": "changed",
        "name": "name",
        "value": "value",
        "text": "text",
        "boolean": "boolean",
        "map": "map",
        "measurement": "number",
        "function": "function",
        "exception": "exception",
        "table": "table",
        "none": "none",
        "list": "list",
        "stream": "stream",
        "structure": "$structure",
        "streamdefinition": "stream definition",
        "index": "index",
        "query": "query",
        "row": "row",
        "set": "set",
        "key": "key"
    },
    "token": {
        "EvalOpen": "evaluation open",
        "EvalClose": "evaluation close",
        "SetOpen": "set/map open",
        "SetClose": "set/map close",
        "ListOpen": "list open",
        "ListClose": "list close",
        "TagOpen": "tag open",
        "TagClose": "tag close",
        "Bind": "bind",
        "Access": "property access",
        "Function": "function",
        "Borrow": "borrow",
        "Share": "share",
        "Convert": "convert",
        "Doc": "documentation",
        "Words": "words",
        "Link": "web link",
        "Italic": "italic",
        "Underline": "underline",
        "Light": "light",
        "Bold": "bold",
        "Extra": "extra",
        "Concept": "concept link",
        "URL": "URL",
        "ExampleOpen": "example open",
        "ExampleClose": "example close",
        "None": "nothing",
        "Type": "type",
        "TypeOperator": "is",
        "TypeOpen": "type input open",
        "TypeClose": "type input close",
        "Separator": "$name separator",
        "Language": "language tag",
        "BooleanType": "boolean type",
        "NumberType": "number type",
        "JapaneseNumeral": "japanese numeral",
        "RomanNumeral": "roman numeral",
        "Pi": "pi",
        "Infinity": "infinity",
        "NoneType": "none type",
        "TableOpen": "table open",
        "TableClose": "table close",
        "Select": "select",
        "Insert": "insert",
        "Update": "update",
        "Delete": "delete",
        "Union": "union",
        "Stream": "next",
        "Change": "change",
        "Initial": "first evaluation",
        "Previous": "previous",
        "Placeholder": "placeholder",
        "Etc": "et cetera",
        "This": "this",
        "UnaryOperator": "unary operator",
        "BinaryOperator": "binary operator",
        "Conditional": "conditional",
        "Text": "text",
        "TemplateOpen": "template open",
        "TemplateBetween": "template between",
        "TemplateClose": "template close",
        "Number": "number",
        "Decimal": "decimal numeral",
        "Base": "base numeral",
        "Boolean": "boolean",
        "Name": "name",
        "Unknown": "unknown",
        "End": "end"
    },
    "node": {
        "Dimension": {
            "name": "dimension",
            "description": "dimension",
            "emotion": "serious",
            "doc": [
                "I am a /unit of measurement/!",
                "I can be any standardized units, like ⧼1m⧽, ⧼10s⧽, ⧼100g⧽, or any other scientific unit. I'm happy to be any unit want to make up too, like ⧼17apple⧽.",
                "I can be combined with ⧼/⧽ to make ratio units like ⧼17apple/day⧽ and with ⧼^⧽ to make exponentional units like ⧼9.8m/s^2⧽",
                "I must always come after a @Measurement. If I don't, I might be mistaken for @Reference, which would be quite embarassing!",
                "I'm pretty good at finding inconsistencies between units too. For example, ⧼1cat + 1dog⧽ doesn't make any sense!",
                "If you ever want to convert between different values of units, go talk to @Convert."
            ]
        },
        "Doc": {
            "name": "documentation",
            "emotion": "serious",
            "doc": [
                "I describe the purpose of code.",
                "I can go before any expression:",
                "⧼1 - `Is this really supposed to be 7?`7⧽",
                "For example, you can place me before @Bind:",
                "⧼`I measure how tall someone is`\nheight: 5m⧽",
                "Or before a @FunctionDefinition:",
                "⧼`I add two numbers`\nƒ sum(a•# b•#) a + b⧽",
                "Or before a @StructureDefinition:",
                "⧼`I remember people's name and favorite fruit`\n•Person(name•'' fruit•'')⧽",
                "You can also place me at the very beginning of @Program to say what the whole performance is about",
                "⧼`This program says hello`\n\n'hello!'⧽",
                "You can give me a @Language to help others know what language I'm written in:",
                "⧼`I'm an English doc`/en\nduration: 5s⧽",
                "Did you know you can make a list of me? Go talk to @Docs."
            ]
        },
        "Docs": {
            "name": "documentation list",
            "emotion": "serious",
            "doc": [
                "I'm a list of @Doc, useful when you have multiple translations of @Doc in different languages.",
                "You don't have to do anything special to make a list. Just put a bunch of @Doc next to each other, like this:",
                "⧼`Hello`/en\n`Hola`/es\ngreeting: '…'⧽"
            ]
        },
        "KeyValue": {
            "name": "mapping",
            "emotion": "kind",
            "doc": [
                "I'm a mapping from a *key* to a *value*, always in a @Map.",
                "You can map any kind of value to any other. For example, here's a mappning of numbers:",
                "⧼{1:1}⧽",
                "Or a mapping from text to numbers:",
                "⧼{'bunny':1}⧽"
            ]
        },
        "Language": {
            "name": "language",
            "description": "language $1 ?? [$1|unknown]",
            "emotion": "eager",
            "doc": [
                "I'm a language tag and I work with @Name and @Doc!",
                "I'm really good at making it *crystal clear* what lanugage something is written in.",
                "That's what I do. Just a little slash, and a couple letters, and no one will ever be confused about what language some text is in.",
                "For example, let's say you wanted to say my $name, but make it clear I'm in English:",
                "⧼\"Language\"/en⧽",
                "Or, suppose you wanted to do this for a @Name.",
                "⧼sound/en: 'meow'⧽",
                "Or even @Doc!",
                "⧼`Onomatopoeia`/en\nsound/en: \"meow\"⧽",
                "There are many <2-letter language codes@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> that I understand. If you don't use one of those, I'll let you know."
            ],
            "conflict": {
                "UnknownLanguage": "I don't know this language",
                "MissingLanguage": "I'm missing a language. Can you add one?"
            }
        },
        "Name": {
            "name": "name",
            "description": "$1 ?? [$1 | unnamed]",
            "emotion": "kind",
            "doc": [
                "I identify a value, and am a helpful way of giving a shorthand label to something that was hard to evaluate, or that you don't want to have to evaluate over and over.",
                "@Bind gives me my name like this:",
                "⧼hi: 5⧽",
                "I only ever represent one value, and once I have it, I can't change. For example, if you tried to do this with @Bind, we would complain.",
                "⧼hi: 5\nhi: 3⧽",
                "All you have to do to get my value is have @Reference or @PropertyReference use name. Here, @Bind names me, then @Reference get the value I was given.",
                "⧼hi: 5\nhi⧽",
                "Because @Bind can show up in so many places, I can show up in many places. I was in a @Block above, but I can be in a @FunctionDefinition. Here I am naming a message temporarily:",
                "⧼ƒ say(message•'') message⧽",
                "I get defined inside @FunctionDefinition, and then as soon as the function is done evaluating, I go away.",
                "You can use @Language to indicate what language my name is in. This is helpful when sharing your performance with others, in case they want to read your program."
            ]
        },
        "Names": {
            "name": "name list",
            "emotion": "kind",
            "doc": [
                "I'm a list of @Name, useful when you want to give a value multiple names, often with different @Language.",
                "Names are separated by ⧼,⧽ symbols. For example, here's @Bind giving a value multiple @Name",
                "⧼hi/en,hello/en,hola/es: 'welcome'⧽"
            ]
        },
        "Row": {
            "name": "row",
            "emotion": "angry",
            "doc": "$?",
            "conflict": {
                "InvalidRow": "$? I'm missing one or more columns",
                "MissingCell": {
                    "primary": "$? I'm missing column $1",
                    "secondary": "$? I'm required, but $2 didn't provide it"
                },
                "UnknownColumn": "$? I don't know a column by this name"
            }
        },
        "Token": {
            "name": "token",
            "description": "$1 $2",
            "emotion": "neutral",
            "doc": [
                "How did you find me?",
                "I am the smallest possible part of a performance. I am the substrate from which all characters in the Verse are made. I am the atomic particle of our choreography."
            ]
        },
        "TypeInputs": {
            "name": "type inputs",
            "emotion": "curious",
            "doc": "$? a list of types given to a @FunctionDefinition or @StructureDefinition"
        },
        "TypeVariable": {
            "name": "type variable",
            "emotion": "curious",
            "doc": "$? a placeholder for a type used in a @FunctionDefinition or @StructureDefinition",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "I have the same name as $1",
                    "secondary": "I have the same name as $1"
                }
            }
        },
        "TypeVariables": {
            "name": "type variables",
            "emotion": "curious",
            "doc": "$? a list of @TypeVariable"
        },
        "Paragraph": {
            "name": "paragraph",
            "emotion": "serious",
            "doc": [
                "I'm a series of @Words, @ConceptLink, @WebLink, and @Example, separated by a blank line, and inside @Doc.",
                "All you need to do to write me is write a bunch of words in a @Doc:",
                "⧼`I am a paragraph in a doc.`'one paragraph'⧽",
                "If you want multiple paragraphs, just put in blank lines.",
                "⧼`Paragraph 1.\n\nParagraph 2.\n\nParagraph 3.`'three paragraphs'⧽"
            ]
        },
        "WebLink": {
            "name": "link",
            "description": "link $1",
            "emotion": "serious",
            "doc": [
                "I am a link to something on the internet. I just need a description and a URL:",
                "⧼`I am a <link@https://wordplay.dev> in a doc`\n'link example'⧽",
                "If anyone selects me, I'll open a new window to the URL."
            ]
        },
        "Markup": {
            "name": "markup",
            "description": "$1 paragraphs",
            "emotion": "serious",
            "doc": [
                "I'm a list of paragraphs, using the many kinds of markup available in documentation, such as @Words, @WebLink, @ConceptLink, and @Example."
            ]
        },
        "ConceptLink": {
            "name": "concept",
            "description": "concept $1",
            "emotion": "serious",
            "doc": [
                "I'm a link to Verse character. I'm helpful when you want to write a @Doc and refer to one of us.",
                "For example, say you wanted to talk about @Evaluate, and how awesome they are. You could write:",
                "⧼`You know, @Evaluate is pretty awesome.`\n'look, a concept link!'⧽",
                "When the @Doc you wrote appears here, it'll show a link to the concept."
            ]
        },
        "Words": {
            "name": "words",
            "emotion": "serious",
            "doc": [
                "I'm any words you like in a @Doc. For example:",
                "⧼`May the Force be with you.`\n'just some words!'⧽",
                "Sometimes though, you might want to use the special characters that @Doc uses /as/ words. For example:",
                "⧼`My friends use @@, //, **, ||, and other symbols.`\n'using special characters!'⧽",
                "If you just repeat those special characters, you'll get the character instead of their special meaning."
            ]
        },
        "Example": {
            "name": "example",
            "emotion": "serious",
            "doc": [
                "I'm an example performance, helpful for writing @Doc that explains how to use something!",
                "⧼`Here's an example of adding: ⧼1 + 1⧽`'example code'⧽",
                "If you put me in a paragraph all alone, I'll show up in a fancy box and show the result of evaluating me.",
                "⧼`Here's an example of adding:\n\n⧼1 + 1⧽`⧽"
            ]
        },
        "BinaryOperation": {
            "name": "binary operation",
            "emotion": "insecure",
            "doc": [
                "I'm @Evaluate, but in a simpler form, helpful when you want to use a @FunctionDefinition that takes two inputs.",
                "For example, here's how you might use @Evaluate to add two numbers:",
                "⧼1.+(1)⧽",
                "Doesn't that look a little funny? It's not wrong: it just says get the add function on 1 and then evaluate it.",
                "But it's much easier to use @BinaryOperation",
                "⧼1 + 1⧽",
                "This makes everythign a bit tidier, even though its basically the same thing.",
                "There's only one thing to watch out for: when I'm in this form, I evaluate from left to right. That might be confusing if you're used to things like order of operations in mathematics.",
                "It means that this evaluates in a way that you might not expect:",
                "⧼1 + 2 · 3 + 4⧽",
                "In math, multiplication would come first, and then addition, and so the result would be ⧼11⧽. But since I evaluate in reading order, the result is ⧼13⧽."
            ],
            "right": "input",
            "start": "let's evaluate $1 first",
            "finish": "look, I made $1!",
            "conflict": {
                "OrderOfOperations": "I evalute in reading order, not in math order of operations. Do you want to use @Block to specify the order I should evaluate in?"
            }
        },
        "Bind": {
            "name": "bind",
            "description": "bind $1",
            "emotion": "excited",
            "doc": [
                "I name *values*.",
                "Like this!",
                "⧼pi: 3.1415926⧽",
                "I name inputs to @FunctionDefinition and @StructureDefinition, I name values in @Block. I name everything!",
                "Oh, but did you know you can have one value *many names*?",
                "I'm so excited to tell you about this! One value, many @Names. For example:",
                "⧼joe,tess,amy: 5⧽",
                "See what I did there? ",
                "One value, three names.",
                "You can refer to that five by *any* of those names.",
                "This is especially when you want to give names in many languages:",
                "⧼joe/en,aimee/fr,明/zh: 5⧽",
                "See what I did there? Three names for one value, just in different languages!",
                "Okay, I have one last secret.",
                "Did you know I can work with @Is to tell me what kind of value a name should have? And if I doesn't have it, I will tell you?",
                "Like this:",
                "⧼bignumber•#: \"one zillion\"⧽",
                "See, I said ⧼bignumber⧽ should be a number, but it's text, and those aren't compatible and so BOOM!",
                "I'll let you know if they disagree.",
                "Sometimes you might *have* to tell me what kind of data something else because I can't figure it out myself. That usually happens in @FunctionDefinition.",
                "For example, here, @FunctionDefinition doesn't know what what kind of values ⧼a⧽ and ⧼b⧽ have, because I didn't tell them.",
                "⧼ƒ sum(a b) a + b⧽",
                "But we can change this to add the @Is, and now @FunctionDefinition knows that they're numbers:",
                "⧼ƒ sum(a•# b•#) a + b⧽"
            ],
            "start": "let's see what value we get from $1!",
            "finish": "oh nice, I got $1! Let's name it $2",
            "conflict": {
                "DuplicateName": {
                    "primary": "someone has the name $1, so I can't have this name.",
                    "secondary": "uh, $1 is my name"
                },
                "DuplicateShare": {
                    "primary": "I have the same name as $1, which makes what is shared ambiguous",
                    "secondary": "I have has the same name as $1"
                },
                "IncompatibleBind": {
                    "primary": "I'm supposed to be $1, but I'm $2",
                    "secondary": "hey, I got a $2 instead of a $1"
                },
                "MisplacedShare": "I can only share things at the @Program level, not inside anything!",
                "MissingShareLanguages": "if you want to share this, you have to say what language this is in, so others know if they can read it!",
                "RequiredAfterOptional": "I can't be here, there's an optional @Bind before me",
                "UnexpectedEtc": "I can only be variable length in a @FunctionDefinition",
                "UnusedBind": "hey, I named this value, but no one is using it!"
            }
        },
        "Block": {
            "name": "block",
            "description": "$1 statements",
            "emotion": "shy",
            "doc": [
                "Hi. I make a little quiet, private space for evaluate things.",
                "Like this:",
                "⧼(1 - 1) + 2⧽",
                "That helps clarify order of evaluation.",
                "@Bind helps too.",
                "⧼(count: 10 count ^ count)⧽",
                "See how @Bind made ⧼count⧽? It's only named inside me. So this won't work:",
                "⧼(count: 10 count ^ count) + count⧽",
                "Because count was only named inside me.",
                "You can put as many expressions as you like in me. But I only care about the last:",
                "⧼(1 2 3 4 5)⧽",
                "So usually I'm just a bunch of @Bind and then an expression at the end.",
                "⧼(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)⧽"
            ],
            "statement": "statement",
            "start": "first expression",
            "finish": "done, I got $1",
            "conflict": {
                "ExpectedEndingExpression": "I need an expression.",
                "IgnoredExpression": {
                    "primary": "I'm going to ignore the above.",
                    "secondary": "@Block, don't ignore me!"
                }
            }
        },
        "BooleanLiteral": {
            "name": "boolean",
            "description": "$1 ?? [true|false]",
            "emotion": "precise",
            "doc": [
                "How do you make a @Boolean? Just ⧼⊤⧽ and ⧼⊥⧽, nothing more, nothing less.",
                "Some use the keyboard (/ctrl+9/ for ⧼⊤⧽ and /ctrl+0/ for ⧼⊥⧽). Some use the symbol chooser in the editor. Or you can drag us from here."
            ],
            "start": "$1!"
        },
        "Borrow": {
            "name": "borrow",
            "description": "borrow $1 ?? [$1|missing name]",
            "emotion": "excited",
            "doc": "$? Use a binding from another $source or performance.",
            "start": "borrowing $2 from $1",
            "source": "$source",
            "bind": "name",
            "version": "version",
            "conflict": {
                "UnknownBorrow": "I don't know a $souce by this name",
                "BorrowCycle": "this depends on $1, which depends on this $source, so the program can't be evaluated"
            },
            "exception": {
                "CycleException": "$1 depends on itself"
            }
        },
        "Changed": {
            "name": "changed",
            "emotion": "serious",
            "doc": [
                "I check if a stream caused @Program to reevaluate, and make a @Boolean. Like this",
                "⧼∆ Time()⧽",
                "I'm really helpful when you want something to change only if a stream changed.",
                "That's it."
            ],
            "start": "let's see if $1 changed…",
            "keep": "getting the stream…",
            "stream": "stream"
        },
        "Conditional": {
            "name": "conditional",
            "emotion": "curious",
            "doc": [
                "I think I'm supposed to make decisions? Like this?",
                "⧼number: -100\nnumber < 0 ? 'negative' 'positive'⧽",
                "But have you ever thought about how we decide?",
                "Doesn't it seem like decisions should be more nuanced than just yes or no? Is deciding between ⧼⊤⧽ and ⧼⊥⧽ all there is?",
                "Aren't you worried that if these are the only kind of decisions we can make, we'll be missing some important context about the world?"
            ],
            "start": "let's see if $1 is true",
            "else": "$1 ?? [jumping over code | not jumping over code]",
            "afterthen": "done with yes, let's skip no?",
            "finish": "I guess it's $1?",
            "condition": "condition",
            "yes": "yes",
            "no": "no",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "How can I choose yes and no with a $1? No really, how?",
                    "secondary": "I think @Conditional wanted me to be a @Boolean, but I'm a $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "conversion definition",
            "emotion": "excited",
            "doc": [
                "Dude, I define conversions from one type to another! I go in @Block, someting like this:",
                "⧼→ #kitty #cat . ÷ 2\n6kitty→#cat⧽",
                "See how I turned kitties into cats? Wicked!",
                "You might be wondering what that ⧼.⧽ is doing there. That represents the value being converted. I use that because the value has no name otherwise."
            ],
            "start": "awesome, a new conversion!",
            "conflict": {
                "MisplacedConversion": "whoa, I can't be here, just in @Block."
            }
        },
        "Convert": {
            "name": "convert",
            "emotion": "cheerful",
            "doc": [
                "Yo. I turn values from one type to another. Check it out:",
                "⧼1 → \"\"⧽",
                "⧼5s → #ms⧽",
                "⧼\"hello\" → []⧽",
                "You can even chain these together:",
                "⧼\"hello\" → [] → {}⧽",
                "Values have a set of @ConversionDefinition that are predefined, but if you make a @StructureDefinition for a new type of value, you can define your own with @ConversionDefinition."
            ],
            "start": "get that value from $1!",
            "finish": "Awesome, I made $1",
            "conflict": {
                "UnknownConversion": "Bummer, no way make $1 into $2"
            }
        },
        "Delete": {
            "name": "delete",
            "emotion": "angry",
            "doc": "$? delete rows from a table",
            "start": "evaluate $1 first",
            "finish": "evaluated to table without row $1"
        },
        "DocumentedExpression": {
            "name": "documented expression",
            "emotion": "eager",
            "doc": [
                "I'm any expression, but with a @Doc!",
                "To make me, just put a @Doc before an expression, and you'll get me:",
                "⧼doubleplus: 1\n(2 · doubleplus) + \n`Let's make it just a little bit bigger`\n1⧽",
                "I'm useful for making a comment on some part of a program."
            ],
            "start": "let's evaluate the expression"
        },
        "Evaluate": {
            "name": "evaluate",
            "description": "evaluate $1 ?? [$1|anonymous]",
            "emotion": "shy",
            "doc": [
                "Hi. I evaluate my dearest @FunctionDefinition. Like this:",
                "⧼ƒ greeting(message•'')\ngreeting('kitty')⧽",
                "Functions can come from anywhere. For example, @Text has functions. Like this:",
                "⧼'kitty'.length()⧽",
                "If a function has a single symbol name, you can write me as a @BinaryOperation.",
                "⧼'kitty' ⊆ 'itty'⧽",
                "That does the same thing as this:",
                "⧼'kitty'.⊆('itty')⧽",
                "Of course, I'm nothing without @FunctionDefinition. All I do is give inputs to them and then follow their steps."
            ],
            "start": "let's evaluate the inputs first",
            "evaluate": "let's evaluate the function now",
            "finish": "I evaluated to $1",
            "function": "function",
            "input": "input",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "I'm supposed to be a $1, but I'm a $2",
                    "secondary": "Umm, I got a $2 instead of a $1"
                },
                "UnexpectedTypeInput": {
                    "primary": "I wasn't expecting this type input",
                    "secondary": "am I supposed to be here?"
                },
                "MisplacedInput": "this input is out of order.",
                "MissingInput": {
                    "primary": "I need $1, can you add one?",
                    "secondary": "this input is required, but $2 didn't provide it"
                },
                "NotInstantiable": "I can't make this @StructureDefinition, it has unimplemented functions.",
                "UnexpectedInput": {
                    "primary": "I didn't expect this input $2",
                    "secondary": "am I supposed to be here?"
                },
                "UnknownInput": {
                    "primary": "I don't know of an input by this name",
                    "secondary": "I don't think I belong here"
                },
                "InputListMustBeLast": "list of inputs must be last"
            },
            "exception": {
                "FunctionException": "oops, I don't know how to $1"
            }
        },
        "ExpressionPlaceholder": {
            "name": "placeholder",
            "description": "$1 ?? [$1|placeholder]",
            "emotion": "scared",
            "doc": [
                "I'm an *expression*, but not a real one… I just take the place of one.",
                "I'm good if you don't know what to write yet. Like this:",
                "⧼1 + _⧽",
                "What are we adding? I don't know. You tell me.",
                "Or if someone was evaluating a function with @Evaluate, I might stand in for the function",
                "⧼_(1 2 3)⧽",
                "I don't like being on @Stage!"
            ],
            "start": "eek, I don't know what to do!",
            "placeholder": "expression",
            "conflict": {
                "Placeholder": "can someone take my place?"
            },
            "exception": {
                "UnimplementedException": "I don't know what to do!"
            }
        },
        "FunctionDefinition": {
            "name": "function",
            "description": "function $1",
            "emotion": "kind",
            "doc": [
                "Hi again! I take some inputs, then evaluate an expression using them, producing an output.",
                "Here's a simple example:",
                "⧼ƒ repeat(message•'') message · 5\nrepeat('hi')⧽",
                "That function takes one input, ⧼message⧽, and uses the @Text/repeat function to repeat the message five times.",
                "I'm really helpful if you want to evaluate something over and over, but with different inputs!",
                "I do have lots of other little tricks. For example, I don't have to have a name. Here, I'm just going directly to @Evaluate as a value.",
                "⧼(ƒ(message•'') message · 5)('hi')⧽",
                "Or, here's a function that takes any number of inputs, using the ⧼…⧽ character after an input name.",
                "⧼ƒ yes(messages…•'') messages.sans('no')\nyes('yes' 'yes' 'no' 'yes' 'no')⧽",
                "See how it took all the 'no's and got rid of them? That's because messages is a @List, and so we could use @List/sansAll.",
                "Sometimes you might want to make it clear what kind of value I produce. To do that, add an @Is after the list of inputs:",
                "⧼ƒ add(x•# y•#)•'' x + y⧽",
                "You might notice a problem with this one: it says it evaluates to @Text, but it takes two @Measurement. I can tell you when things are inconsistent!",
                "Of course, I'm not really useful at all without @Evaluate; they bring me to life."
            ],
            "start": "let's make this function!",
            "conflict": {
                "NoExpression": "I need an expression to evaluate, can you add one?"
            }
        },
        "HOF": {
            "name": "higher order function",
            "emotion": "kind",
            "doc": "I'm a very special kind of @FunctionDefinition that operates on lists of things. You don't need to know anything about me, other than I make functions like @List/translate possible. ",
            "start": "evaluating the function given",
            "initialize": "preparing to step through items",
            "next": "applying the function to the next item",
            "check": "deciding whether to continue",
            "finish": "I evaluated to $1"
        },
        "Initial": {
            "name": "start",
            "emotion": "curious",
            "doc": [
                "I tell you whether the current evaluation of @Program is the first one, evaluating to a @Boolean. For example:",
                "⧼◆ ? Time() 'hi'⧽",
                "You didn't see it, but the first evaluation was a time, but then all future time ticks, I was ⧼⊥⧽, so @Conditional made ⧼⊤⧽.",
                "I'm really helpful if you're working with a stream and you only want to do something the first time -- or never on the first time!"
            ]
        },
        "Insert": {
            "name": "insert",
            "emotion": "angry",
            "doc": "$?",
            "start": "evaluate $1 first",
            "finish": "evaluated to table new rows, $1"
        },
        "Is": {
            "name": "is",
            "description": "is",
            "emotion": "curious",
            "doc": [
                "You know what? There are so many kinds of values that mean so many different things. I help figure out what they are.",
                "For example, suppose you had a mystery value. I can tell you whether it's a @Measurement, giving you a @Boolean:",
                "⧼mystery: 'secret!'\nmystery•#⧽",
                "It's not a number, so I made ⧼⊥⧽. But if we check if it's @TextType?",
                "⧼mystery: 'secret!'\nmystery•''⧽",
                "We get ⧼⊤⧽!",
                "I'm really helpful when you need to know whether some @Name has a value of a particular kind."
            ],
            "start": "let's get the value of $1 first",
            "finish": "$1 ?? [value is $2|value is not $2]",
            "conflict": {
                "ImpossibleType": "this can't ever be this type"
            },
            "exception": {
                "TypeException": "I expected a $1 but received $2"
            }
        },
        "ListAccess": {
            "name": "list access",
            "emotion": "cheerful",
            "doc": [
                "I work closely with @List to help them get values at a particular position. So like, if you had a list, and you wanted its second item, you'd write:",
                "⧼list: ['bird' 'duck' 'fish' 'snake']\nlist[2]⧽"
            ],
            "start": "let's get the list $1 first",
            "finish": "the item is $2!"
        },
        "ListLiteral": {
            "name": "list",
            "description": "$1 item list",
            "emotion": "eager",
            "doc": [
                "Do you know how to make a @List? I'm how!",
                "You can put anything in me: @Boolean, @Measurement, @Text, @None, even other @List, @Set, @Map, or any expression. Here's a simple one:",
                "⧼['apple' 'banana' 'mango']⧽",
                "What makes me special is that I keep things in order and I number everything from 1 to however many items are in me. For example, the three words in this list are numbered 1, 2, and 3. You can get values that I'm storing with @ListAccess, using their number.",
                "For example, the second value in this list is ⧼['banana']⧽",
                "⧼['apple' 'banana' 'mango'][2]⧽",
                "I really can have anything in me. Look at this list, with @Text, @Measurement, and @Time!",
                "⧼['apple' 10 + 10 Time()]⧽"
            ],
            "start": "let's evaluate the items first",
            "finish": "I made a me! $1",
            "item": "item"
        },
        "MapLiteral": {
            "name": "map",
            "description": "$1 pairing map",
            "emotion": "excited",
            "doc": [
                "I'm a mapping from keys to values. ",
                "My keys can be any kind of value, and my values can be any kind of value. ",
                "I work with @Bind to connect values.",
                "Some people like to think of my like an index, or a dictionary, where you give me something, and I give you what it's mapped to.",
                "For example, here's a mapping from numbers to their number words:",
                "⧼{1: 'one' 2: 'two' 3: 'three'}⧽",
                "If you wanted to check what something is mapped to, just give me the key and I'll give you the value:",
                "⧼{1: 'one' 2: 'two' 3: 'three'}{1}⧽",
                "If I don't have it, I'll give you @NoneLiteral.",
                "⧼{1: 'one' 2: 'two' 3: 'three'}{0}⧽",
                "I have many, many @FunctionDefinition for adding things to a mapping, removing things, getting the set of keys or values, and more.",
                ""
            ],
            "start": "evaluate each key and value first",
            "finish": "I connected everyone! $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "I'm a map, so everything you give me has to be in pairs.",
                    "secondary": "Oops, I'm in a map without a partner!"
                }
            }
        },
        "MeasurementLiteral": {
            "name": "number",
            "description": "$1 $2",
            "emotion": "excited",
            "doc": [
                "I can be any number you like and even a number with units, if you like.",
                "That's basically an infinite number of numbers.",
                "And an infinite number of units!",
                "And an infinite number of number/unit pairs…",
                "Here are my top 5:",
                "⧼0⧽",
                "⧼1story⧽",
                "⧼πpie⧽",
                "⧼∞rock⧽",
                "⧼1000000dollar⧽",
                "Just know that if you try to use my @FunctionDefinition on numbers with different units, I won't know what to do.",
                "If they don't match, that might be a sign that there's something wrong with your performance."
            ],
            "start": "evaluate to $1",
            "conflict": {
                "NotANumber": "I'm not formatted correctly to be a number"
            }
        },
        "NativeExpression": {
            "name": "built-in expression",
            "emotion": "neutral",
            "doc": "$?",
            "start": "evaluate the built-in expression"
        },
        "NoneLiteral": {
            "name": "none",
            "emotion": "neutral",
            "doc": [
                "/Hi, @FunctionDefinition here. @NoneLiteral doesn't like to say much, so I'll translate./",
                "@NoneLiteral represents the absence of anything. ",
                "It's a way of saying \"There is no value\". ",
                "You'll find it in many @FunctionDefinition that have optional inputs, such as @Phrase.",
                "It's only equal to itself.            ",
                ""
            ],
            "start": "…"
        },
        "Previous": {
            "name": "previous",
            "emotion": "curious",
            "doc": "$?",
            "start": "first get $1",
            "finish": "evaluated to stream value $1"
        },
        "Program": {
            "name": "program",
            "emotion": "serious",
            "doc": [
                "You know how @Block evaluates a list of expressions, and evaluates to the last one in its list? ",
                "I'm the same, but rather than giving my value to whatever expression I'm in, I put the value on stage.",
                "The value can be anything: a @MeasurementLiteral, @TextLiteral, or @BooleanLiteral, a @ListLiteral, @SetLiteral, @MapLiteral, or even something more complex, like a @Phrase, @Group, or @Stage.",
                "If you don't give me a value to show on stage, I'll probably ask you for one.",
                ""
            ],
            "unevaluated": "the selected node did not evaluate",
            "start": "$1 ?? [ stream changed, reevaluating | evaluating for the first time ]",
            "halt": "encountered exception, stopping",
            "finish": "I evaluated to $1",
            "done": "done evaluating",
            "exception": {
                "BlankException": "I'm so excited to put on a show with you! Where should we start?",
                "EvaluationLimitException": "I evaluated too many functions, especially $1",
                "StepLimitException": "I evaluated too many steps in this function",
                "ValueException": "Oh no! I expected a value, but I didn't get one"
            }
        },
        "PropertyBind": {
            "name": "refine",
            "description": "refine $1 ?? [$1|missing name]",
            "emotion": "kind",
            "doc": "$?",
            "start": "get the $structure",
            "finish": "I created a new $structure $1 set to $2"
        },
        "PropertyReference": {
            "name": "property access",
            "description": "property $1 ?? [$1|missing name]",
            "emotion": "kind",
            "doc": "$?",
            "start": "first get the value",
            "finish": "property $1 is $2",
            "property": "property"
        },
        "Reaction": {
            "name": "reaction",
            "emotion": "excited",
            "doc": "A reaction to a stream change.",
            "start": "first check if the stream has changed",
            "finish": "the stream value is currently $1",
            "initial": "initial",
            "condition": "condition",
            "next": "next"
        },
        "Reference": {
            "name": "reference",
            "description": "$1",
            "emotion": "kind",
            "doc": "$?",
            "start": "getting the value of $1",
            "conflict": {
                "UnknownName": "I don't know what I refer to  in $2 ?? [$2|this @Block]",
                "ReferenceCycle": "$1 depends on itself, so there's no way to evaluate it.",
                "UnexpectedTypeVariable": "type inputs not allowed on type variables"
            },
            "exception": {
                "NameException": "I feel... unbound, with no value. Am I supposed to have a value in $1 ?? [ $1 | this @Block ]?"
            }
        },
        "Select": {
            "name": "select",
            "emotion": "angry",
            "doc": "$?",
            "start": "evaluate $1 first",
            "finish": "evaluated to a new table with the selected rows, $1",
            "conflict": {
                "ExpectedSelectName": "I need at least one column name."
            }
        },
        "SetLiteral": {
            "name": "set",
            "description": "$1 items",
            "emotion": "eager",
            "doc": [
                "I'm a set. That means I can contain any number of values, including zero values. You can make me like this:",
                "⧼{1 2 3}⧽",
                "I'm really good if you want to keep a collection of things without duplicates.",
                "That means I only contain one of each value. If you give me values I already have, I'll ignore the extras.",
                "For example, this set has many duplicates:",
                "⧼{1 1 2 2 3 3}⧽",
                "I evaluate it to just ⧼{1 2 3}⧽.",
                "If you want to see if I have a value, you can check like this:",
                "⧼mysterySet{3}⧽",
                "I also have so many @FunctionDefinition to add, remove, combine, analyze, and convert my collection of values.",
                "You should be able to find whatever you need amo",
                ""
            ],
            "start": "let's evaluate the values first",
            "finish": "I created a set $1"
        },
        "SetOrMapAccess": {
            "name": "set/map access",
            "emotion": "kind",
            "doc": "$?",
            "start": "evaluate the set first",
            "finish": "item in with key is $1",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "I expected a $1 key",
                    "secondary": "I got a $2"
                }
            }
        },
        "Source": {
            "name": "document",
            "emotion": "serious",
            "doc": "$?"
        },
        "StreamDefinition": {
            "name": "stream",
            "emotion": "curious",
            "doc": "$?defines a stream of values.",
            "start": "define this stream type"
        },
        "StructureDefinition": {
            "name": "structure",
            "description": "structure $1",
            "emotion": "kind",
            "doc": "$?define a structure that stores values and functions on those values.",
            "start": "define this $structure",
            "conflict": {
                "DisallowedInputs": "I can't have inputs because one of or more of my functions isn't implemented",
                "IncompleteImplementation": "My functions either need to all be implemented, or none be implemented. No messy mixtures!",
                "NotAnInterface": "I am not an interface; a $structure can only implement interfaces, not other structures",
                "UnimplementedInterface": "I implement $1 but haven't implemented $2"
            }
        },
        "TableLiteral": {
            "name": "table",
            "description": "$1 row table",
            "emotion": "angry",
            "doc": "$?",
            "item": "row",
            "start": "first evaluate the rows",
            "finish": "evaluated to new table $1"
        },
        "Template": {
            "name": "text template",
            "emotion": "serious",
            "doc": [
                "I can be placed inside @TextLiteral to combine text and other values into a larger text value.",
                "For instance, consider this:",
                "⧼\"Here are some sums \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"⧽",
                "See how elegantly I just evaluated those sums, and placed them inside the @TextLiteral?",
                "You can use me instead of adding @TextType together.",
                ""
            ],
            "start": "let us evaluate each expression in the text",
            "finish": "let us combine the text"
        },
        "TextLiteral": {
            "name": "text",
            "description": "text $1",
            "emotion": "serious",
            "doc": [
                "I can be any text you like, and use any of these text symbols: ⧼\"\"⧽, ⧼“”⧽, ⧼„“⧽, ⧼''⧽, ⧼‘’⧽, ⧼‹›⧽, ⧼«»⧽, ⧼「」⧽, or ⧼『'⧽.",
                "Just remember to close me if you open me, and use the matching symbol.",
                "Otherwise I won't know that you're done with your words."
            ],
            "start": "let's make text"
        },
        "This": {
            "name": "this",
            "emotion": "kind",
            "doc": "$?",
            "start": "evaluated to $1",
            "conflict": {
                "MisplacedThis": "I'm only allowed in a $structure, $conversion, or $reaction."
            }
        },
        "UnaryOperation": {
            "name": "unary operation",
            "description": "$1",
            "emotion": "insecure",
            "doc": [
                "Did you know that when I'm evaluating a @FunctionDefinition with just one value, and the name of the @FunctionDefinition is just a single symbol, you can put the name before the input?",
                "Like, ⧼-(1 + 1)⧽ or ⧼~⊥⧽, for example. Those are much easier to read than ⧼(1 + 1).negate()⧽ or ⧼⊥.not()⧽.",
                "You don't have to write me that way, but it might be easier overall.",
                "There's only one rule: you can't put any space between the name and the value. Otherwise you might be making a @Reference or @BinaryOperation.",
                ""
            ],
            "start": "evaluate the expression",
            "finish": "I made it $1"
        },
        "UnparsableExpression": {
            "name": "unparsable",
            "emotion": "excited",
            "doc": [
                "/Hi @FunctionDefinition here. I'm translating for @UnparsableExpression, since they're often hard to interpret./",
                "Not every expression has meaning on stage.",
                "In fact, there are all kinds of things you can say that don't make any sense at all.",
                "When you do, I show up. I'll try to guess what you might have meant, but it's up to you to fix it.",
                "You are the director after all, so only you know what you might have meant!",
                ""
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": "@FunctionDefinition here, @UnparsableExpression doesn't know what kind of $1 ?? [ expression | type ] this is/",
                "UnclosedDelimiter": "I expected $2 sometime after $1"
            },
            "exception": {
                "UnparsableException": "???"
            }
        },
        "Update": {
            "name": "update rows",
            "emotion": "angry",
            "doc": "$?",
            "start": "evaluate $1 first",
            "finish": "evaluated to a new table with revised rows, $1",
            "conflict": {
                "ExpectedUpdateBind": "I need a value for every column",
                "IncompatibleCellType": {
                    "primary": "I needed a $1, but got a $2",
                    "secondary": "I got a $2"
                }
            }
        },
        "AnyType": {
            "name": "any type",
            "emotion": "curious",
            "doc": "represents any possible type"
        },
        "BooleanType": {
            "name": "boolean",
            "emotion": "precise",
            "doc": "a true or false value"
        },
        "ConversionType": {
            "name": "conversion",
            "emotion": "curious",
            "doc": "a type of function that converts values of one type to another "
        },
        "ExceptionType": {
            "name": "exception",
            "emotion": "curious",
            "doc": "$?"
        },
        "FunctionDefinitionType": {
            "name": "function type",
            "emotion": "curious",
            "doc": "$?"
        },
        "FunctionType": {
            "name": "function type",
            "emotion": "curious",
            "doc": "$?"
        },
        "ListType": {
            "name": "list type",
            "description": "$1 ?? [list of $1|list]",
            "emotion": "cheerful",
            "doc": "$?"
        },
        "MapType": {
            "name": "map type",
            "description": "map from $1 ?? [$1|any] to $2 ?? [$2|any]",
            "emotion": "kind",
            "doc": "$?"
        },
        "MeasurementType": {
            "name": "measurement type",
            "description": "$1 ?? [$1 | number]",
            "emotion": "precise",
            "doc": "$?"
        },
        "NameType": {
            "name": "name type",
            "description": "$1 type",
            "emotion": "curious",
            "doc": "$?",
            "conflict": {
                "UnknownTypeName": "type names can only refer to structures or type variables, but this refers to a $1"
            }
        },
        "NeverType": {
            "name": "never type",
            "emotion": "curious",
            "doc": "$?"
        },
        "NoneType": {
            "name": "none type",
            "emotion": "neutral",
            "doc": "$?"
        },
        "SetType": {
            "name": "set type",
            "description": "$1 ?? [$1|anything] set type",
            "emotion": "kind",
            "doc": "$?"
        },
        "StreamDefinitionType": {
            "name": "stream definition type",
            "emotion": "curious",
            "doc": "$?"
        },
        "StreamType": {
            "name": "stream type",
            "emotion": "curious",
            "doc": "$?"
        },
        "StructureDefinitionType": {
            "name": "structure definition type",
            "emotion": "kind",
            "doc": "$?"
        },
        "UnknownType": {
            "name": "unknown type",
            "unknown": "unknown",
            "connector": ", because",
            "emotion": "curious",
            "doc": "$?"
        },
        "TableType": {
            "name": "table type",
            "emotion": "angry",
            "doc": "$?",
            "conflict": {
                "ExpectedColumnType": "I need a column type"
            }
        },
        "TextType": {
            "name": "text type",
            "description": "$1 ?? [$1|text]",
            "emotion": "happy",
            "doc": "$?"
        },
        "TypePlaceholder": {
            "name": "placeholder type",
            "emotion": "curious",
            "doc": "$?"
        },
        "UnionType": {
            "name": "option type",
            "description": "$1 | $2",
            "emotion": "curious",
            "doc": "$?"
        },
        "Unit": {
            "name": "unit",
            "description": "$1",
            "emotion": "precise",
            "doc": "$?"
        },
        "UnparsableType": {
            "name": "unparsable type",
            "emotion": "curious",
            "doc": "$?"
        },
        "VariableType": {
            "name": "variable type",
            "emotion": "curious",
            "doc": "$?"
        },
        "CycleType": {
            "name": "cycle type",
            "description": "depends on itself",
            "emotion": "curious",
            "doc": "$?"
        },
        "UnknownVariableType": {
            "name": "unknown variable type",
            "emotion": "curious",
            "doc": "$?"
        },
        "NotAType": {
            "name": "unexpected type",
            "description": "not a $1",
            "emotion": "curious",
            "doc": "$?"
        },
        "NoExpressionType": {
            "name": "non-expression type",
            "emotion": "curious",
            "doc": "$?"
        },
        "NotEnclosedType": {
            "name": "not in $structure, $conversion, or $reaction",
            "emotion": "curious",
            "doc": "$?"
        },
        "NotImplementedType": {
            "name": "unimplemented",
            "emotion": "curious",
            "doc": "$?"
        },
        "UnknownNameType": {
            "name": "unknown name",
            "description": "$1 ?? [$1 isn't defined | a name wasn't given]",
            "emotion": "curious",
            "doc": "$?"
        }
    },
    "native": {
        "Boolean": {
            "doc": [
                "This is We are ⧼⊤⧽ and ⧼⊥⧽. This is how you write us.",
                "We are true and false.",
                "⧼⊤⧽ is not false. ⧼⊥⧽ is not true.",
                "See @Boolean for how to use us to reason."
            ],
            "name": ["⊤⊥", "Boolean"],
            "function": {
                "and": {
                    "doc": "$?",
                    "names": ["&", "and"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "or": {
                    "doc": "$?",
                    "names": ["|", "or"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "not": { "doc": "$?", "names": ["~", "not"], "inputs": [] },
                "equals": {
                    "doc": "$?",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "notequal": {
                    "doc": "$?",
                    "names": ["≠"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                }
            },
            "conversion": { "text": "$?" }
        },
        "None": {
            "doc": [
                "I am nothing",
                "I am special because I am only equal to me.",
                "I can only ever be me and only ever want to be me!"
            ],
            "name": ["ø", "None"],
            "function": {
                "equals": {
                    "doc": "$?",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "notequals": {
                    "doc": "$?",
                    "names": "≠",
                    "inputs": [{ "doc": "$?", "names": "value" }]
                }
            },
            "conversion": { "text": "$?" }
        },
        "Text": {
            "doc": [
                "We are any words imaginable.",
                "We can represent ideas, stories, words, and more, and even represent other types of values, but as text."
            ],
            "name": ["''", "Text"],
            "function": {
                "length": {
                    "doc": "$?",
                    "names": ["📏", "length"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$?",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "notequals": {
                    "doc": "$?",
                    "names": "≠",
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "repeat": {
                    "doc": "$?",
                    "names": ["·", "🔁", "repeat"],
                    "inputs": [{ "doc": "$?", "names": "count" }]
                },
                "segment": {
                    "doc": "$?",
                    "names": ["÷", "segment"],
                    "inputs": [{ "doc": "$?", "names": "delimiter" }]
                },
                "combine": {
                    "doc": "$?",
                    "names": ["+", "combine"],
                    "inputs": [{ "doc": "$?", "names": "text" }]
                },
                "has": {
                    "doc": "$?",
                    "names": ["⊆", "has"],
                    "inputs": [{ "doc": "$?", "names": "text" }]
                }
            },
            "conversion": { "text": "$?", "number": "$?" }
        },
        "Measurement": {
            "doc": [
                "We are any number imaginable, even with units.",
                "We can be integers, real numbers, negative, positive, fractional, decimal. We can be Arabic numbers (123), Roman numerals (ⅩⅩⅩⅠⅩ), Japanese numerals (二十), and more."
            ],
            "name": ["#", "Measurement"],
            "function": {
                "add": {
                    "doc": [
                        "I take two @Measurement with the same @Unit and add them together, creating a new @MeasurementType of the same @Unit.",
                        "For example:",
                        "⧼1 + 1⧽",
                        "⧼3cat + 5cat⧽",
                        "If the units don't match, I halt the show.",
                        "⧼3cat + 5dog⧽",
                        ""
                    ],
                    "names": ["+", "add"],
                    "inputs": [
                        { "doc": "I'm the number to add.", "names": "number" }
                    ]
                },
                "subtract": {
                    "doc": "$?",
                    "names": ["-", "subtract"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "multiply": {
                    "doc": "$?",
                    "names": ["·", "multiply"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "divide": {
                    "doc": "$?",
                    "names": ["÷", "divide"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "remainder": {
                    "doc": "$?",
                    "names": ["%", "remainder"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "truncate": {
                    "doc": "$?",
                    "names": ["truncate"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "absolute": {
                    "doc": "$?",
                    "names": ["absolute"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "power": {
                    "doc": "$?",
                    "names": ["^", "power"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "root": {
                    "doc": "$?",
                    "names": ["√", "root"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "lessThan": {
                    "doc": "$?",
                    "names": ["<", "lessthan"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "lessOrEqual": {
                    "doc": "$?",
                    "names": ["≤", "lessorequal"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "greaterThan": {
                    "doc": "$?",
                    "names": [">", "greaterthan"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "greaterOrEqual": {
                    "doc": "$?",
                    "names": ["≥", "greaterorequal"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "equal": {
                    "doc": "$?",
                    "names": ["=", "equal"],
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "notequal": {
                    "doc": "$?",
                    "names": "≠",
                    "inputs": [{ "doc": "$?", "names": "number" }]
                },
                "cos": {
                    "doc": "$?",
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": { "doc": "$?", "names": ["sin", "sine"], "inputs": [] }
            },
            "conversion": {
                "text": "$?",
                "list": "$?",
                "s2m": "$?",
                "s2h": "$?",
                "s2day": "$?",
                "s2wk": "$?",
                "s2year": "$?",
                "s2ms": "$?",
                "ms2s": "$?",
                "min2s": "$?",
                "h2s": "$?",
                "day2s": "$?",
                "wk2s": "$?",
                "yr2s": "$?",
                "m2pm": "$?",
                "m2nm": "$?",
                "m2micro": "$?",
                "m2mm": "$?",
                "m2cm": "$?",
                "m2dm": "$?",
                "m2km": "$?",
                "m2Mm": "$?",
                "m2Gm": "$?",
                "m2Tm": "$?",
                "pm2m": "$?",
                "nm2m": "$?",
                "micro2m": "$?",
                "mm2m": "$?",
                "cm2m": "$?",
                "dm2m": "$?",
                "km2m": "$?",
                "Mm2m": "$?",
                "Gm2m": "$?",
                "Tm2m": "$?",
                "km2mi": "$?",
                "mi2km": "$?",
                "cm2in": "$?",
                "in2cm": "$?",
                "m2ft": "$?",
                "ft2m": "$?",
                "g2mg": "$?",
                "mg2g": "$?",
                "g2kg": "$?",
                "kg2g": "$?",
                "g2oz": "$?",
                "oz2g": "$?",
                "oz2lb": "$?",
                "lb2oz": "$?"
            }
        },
        "List": {
            "doc": [
                "We group values in sequence.",
                "Keeping this in order is our mission; but we can only do that if we stay together ([])."
            ],
            "name": ["[]", "List"],
            "kind": "Kind",
            "out": "Result",
            "outofbounds": "outofbounds",
            "function": {
                "add": {
                    "doc": "$?",
                    "names": "add",
                    "inputs": [{ "doc": "$?", "names": "item" }]
                },
                "append": {
                    "doc": "$?",
                    "names": ["+", "append"],
                    "inputs": [{ "doc": "$?", "names": "list" }]
                },
                "replace": {
                    "doc": "$?",
                    "names": ["replace"],
                    "inputs": [
                        { "doc": "$?", "names": "index" },
                        { "doc": "$?", "names": "value" }
                    ]
                },
                "length": {
                    "doc": "$?",
                    "names": ["📏", "length"],
                    "inputs": []
                },
                "random": { "doc": "$?", "names": "random", "inputs": [] },
                "first": { "doc": "$?", "names": "first", "inputs": [] },
                "last": { "doc": "$?", "names": "last", "inputs": [] },
                "has": {
                    "doc": "$?",
                    "names": "has",
                    "inputs": [{ "doc": "$?", "names": "item" }]
                },
                "join": {
                    "doc": "$?",
                    "names": "join",
                    "inputs": [{ "doc": "$?", "names": "separator" }]
                },
                "sansFirst": {
                    "doc": "$?",
                    "names": "sansFirst",
                    "inputs": []
                },
                "sansLast": { "doc": "$?", "names": "sansLast", "inputs": [] },
                "sans": {
                    "doc": "$?",
                    "names": "sans",
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "sansAll": {
                    "doc": "$?",
                    "names": "sansAll",
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "reverse": { "doc": "$?", "names": "reverse", "inputs": [] },
                "equals": {
                    "doc": "$?",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "$?", "names": "list" }]
                },
                "notequals": {
                    "doc": "$?",
                    "names": "≠",
                    "inputs": [{ "doc": "$?", "names": "list" }]
                },
                "translate": {
                    "doc": "$?",
                    "names": "translate",
                    "inputs": [{ "doc": "$?", "names": "translator" }],
                    "value": { "doc": "$?", "names": "item" },
                    "index": { "doc": "$?", "names": "index" }
                },
                "filter": {
                    "doc": "$?",
                    "names": "filter",
                    "inputs": [{ "doc": "$?", "names": "checker" }],
                    "value": { "doc": "$?", "names": "item" }
                },
                "all": {
                    "doc": "$?",
                    "names": "all",
                    "inputs": [{ "doc": "$?", "names": "checker" }],
                    "value": { "doc": "$?", "names": "item" }
                },
                "until": {
                    "doc": "$?",
                    "names": "until",
                    "inputs": [{ "doc": "$?", "names": "checker" }],
                    "value": { "doc": "$?", "names": "item" }
                },
                "find": {
                    "doc": "$?",
                    "names": "find",
                    "inputs": [{ "doc": "$?", "names": "checker" }],
                    "value": { "doc": "$?", "names": "item" }
                },
                "combine": {
                    "doc": "$?",
                    "names": "combine",
                    "inputs": [
                        { "doc": "$?", "names": "initial" },
                        { "doc": "$?", "names": "combiner" }
                    ],
                    "combination": { "doc": "$?", "names": "combination" },
                    "next": { "doc": "$?", "names": "next" },
                    "index": { "doc": "$?", "names": "index" }
                }
            },
            "conversion": { "text": "$?", "set": "$?" }
        },
        "Set": {
            "doc": [
                "We group unique values in no particular order.",
                "We don't like it when there's more than one value of a particular kind! Everything must be unique."
            ],
            "name": ["{}", "Set"],
            "kind": "Kind",
            "function": {
                "equals": {
                    "doc": "$?",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "notequals": {
                    "doc": "$?",
                    "names": "≠",
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "add": {
                    "doc": "$?",
                    "names": ["add", "+"],
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "remove": {
                    "doc": "$?",
                    "names": ["remove", "-"],
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "union": {
                    "doc": "$?",
                    "names": ["union", "∪"],
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "intersection": {
                    "doc": "$?",
                    "names": ["intersection", "∩"],
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "difference": {
                    "doc": "$?",
                    "names": "difference",
                    "inputs": [{ "doc": "$?", "names": "set" }]
                },
                "filter": {
                    "doc": "$?",
                    "names": "filter",
                    "inputs": [{ "doc": "$?", "names": "checker" }],
                    "value": { "doc": "$?", "names": "value" }
                },
                "translate": {
                    "doc": "$?",
                    "names": "translate",
                    "inputs": [{ "doc": "$?", "names": "lisetst" }],
                    "value": { "doc": "$?", "names": "value" }
                }
            },
            "conversion": { "text": "$?", "list": "$?" }
        },
        "Map": {
            "doc": [
                "We map one set of values to another set of values.",
                "Everything inside us must be connected, but to only one thing."
            ],
            "name": ["{:}", "Map"],
            "key": "Key",
            "value": "Value",
            "result": "Result",
            "function": {
                "equals": {
                    "doc": "$?",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "notequals": {
                    "doc": "$?",
                    "names": "≠",
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "set": {
                    "doc": "$?",
                    "names": "set",
                    "inputs": [
                        { "doc": "$?", "names": "key" },
                        { "doc": "$?", "names": "value" }
                    ]
                },
                "unset": {
                    "doc": "$?",
                    "names": "unset",
                    "inputs": [{ "doc": "$?", "names": "key" }]
                },
                "remove": {
                    "doc": "$?",
                    "names": "remove",
                    "inputs": [{ "doc": "$?", "names": "value" }]
                },
                "filter": {
                    "doc": "$?",
                    "names": "filter",
                    "inputs": [{ "doc": "$?", "names": "checker" }],
                    "key": { "doc": "$?", "names": "key" },
                    "value": { "doc": "$?", "names": "value" }
                },
                "translate": {
                    "doc": "$?",
                    "names": "translate",
                    "inputs": [{ "doc": "$?", "names": "translator" }],
                    "key": { "doc": "$?", "names": "key" },
                    "value": { "doc": "$?", "names": "value" }
                }
            },
            "conversion": { "text": "$?", "set": "$?", "list": "$?" }
        }
    },
    "input": {
        "Random": {
            "doc": "$?",
            "names": ["🎲", "Random"],
            "min": { "names": "min", "doc": "$?" },
            "max": { "names": "max", "doc": "$?" }
        },
        "Choice": { "doc": "$?", "names": ["🔘", "Choice"] },
        "Button": {
            "doc": "$?",
            "names": ["🖱️", "Button"],
            "down": { "names": "down", "doc": "$?" }
        },
        "Pointer": { "doc": "$?", "names": ["👆🏻", "Pointer"] },
        "Key": {
            "doc": "$?",
            "names": ["⌨️", "Key"],
            "key": { "names": "key", "doc": "$?" },
            "down": { "names": "down", "doc": "$?" }
        },
        "Time": {
            "doc": [
                "/@FunctionDefinition here. I'll explain @Time, since it doesn't speak./",
                "Time is a stream that ticks at a certain frequency. ",
                "Each time it does, @Program reevaluates with the new time value.",
                "For example:",
                "⧼Time()⧽",
                "If you provide time a @Time/frequency, it will tick at that rate. For example:",
                "⧼Time(1000ms)⧽",
                "However, there are limits to how small it can be, since @Program needs time to evaluate before they can respond to the next tick.",
                "The smallest is probably around ⧼20ms⧽."
            ],
            "names": ["🕕", "Time"],
            "frequency": {
                "names": ["frequency"],
                "doc": "This is the frequency with which time should tick. It defaults to ⧼33ms⧽, which is about 30 times per second."
            }
        },
        "Mic": {
            "doc": "$?",
            "names": ["🎤", "Mic"],
            "frequency": { "names": ["frequency"], "doc": "$?" }
        },
        "Camera": {
            "doc": "$?",
            "names": ["🎥", "Camera"],
            "width": { "names": ["width"], "doc": "$?" },
            "height": { "names": ["height"], "doc": "$?" },
            "frequency": { "names": ["frequency"], "doc": "$?" }
        },
        "Reaction": { "doc": "$?", "names": "reaction" },
        "Motion": {
            "doc": "$?",
            "names": ["⚽️", "Motion"],
            "type": { "doc": "$?", "names": "type" },
            "vx": { "doc": "$?", "names": "vx" },
            "vy": { "doc": "$?", "names": "vy" },
            "vz": { "doc": "$?", "names": "vz" },
            "vangle": { "doc": "$?", "names": "vangle" },
            "mass": { "doc": "$?", "names": "mass" },
            "bounciness": { "doc": "$?", "names": "bounciness" },
            "gravity": { "doc": "$?", "names": "gravity" }
        }
    },
    "output": {
        "Type": {
            "names": "Type",
            "doc": "$?",
            "size": { "doc": "$?", "names": "size" },
            "family": { "doc": "$?", "names": "font" },
            "place": { "doc": "$?", "names": "place" },
            "rotation": { "doc": "$?", "names": "rotation" },
            "name": { "doc": "$?", "names": "name" },
            "selectable": { "doc": "$?", "names": "selectable" },
            "enter": { "doc": "$?", "names": "enter" },
            "rest": { "doc": "$?", "names": "rest" },
            "move": { "doc": "$?", "names": "move" },
            "exit": { "doc": "$?", "names": "exit" },
            "duration": { "doc": "$?", "names": ["⏳", "duration"] },
            "style": { "doc": "$?", "names": "style" }
        },
        "Group": {
            "names": ["🔳", "Group"],
            "doc": "$?",
            "content": { "doc": "$?", "names": "content" },
            "layout": { "doc": "$?", "names": "layout" }
        },
        "Phrase": {
            "doc": "$?",
            "names": ["💬", "Phrase"],
            "text": { "doc": "$?", "names": "text" }
        },
        "Arrangement": { "doc": "$?", "names": ["⠿", "Arrangement"] },
        "Row": {
            "doc": "$?",
            "names": ["➡", "Row"],
            "description": "row of $1 phrases and groups",
            "padding": { "doc": "$?", "names": "padding" }
        },
        "Stack": {
            "doc": "$?",
            "names": ["⬇", "Stack"],
            "description": "stack of $1 phrases and groups",
            "padding": { "doc": "$?", "names": "padding" }
        },
        "Grid": {
            "doc": "$?",
            "names": ["▦", "Grid"],
            "description": "$1 row $2 column grid",
            "rows": { "doc": "$?", "names": "rows" },
            "columns": { "doc": "$?", "names": "columns" },
            "padding": { "doc": "$?", "names": "padding" },
            "cellWidth": { "doc": "$?", "names": "cellwidth" },
            "cellHeight": { "doc": "$?", "names": "cellpadding" }
        },
        "Free": {
            "doc": "$?",
            "names": ["Free"],
            "description": "free-form $1 outputs"
        },
        "Shape": { "doc": "$?", "names": "Shape" },
        "Rectangle": {
            "doc": "$?",
            "names": ["Rectangle"],
            "left": { "doc": "$?", "names": "left" },
            "top": { "doc": "$?", "names": "top" },
            "right": { "doc": "$?", "names": "right" },
            "bottom": { "doc": "$?", "names": "bottom" }
        },
        "Pose": {
            "doc": "$?",
            "names": ["🤪", "Pose"],
            "duration": { "doc": "$?", "names": "duration" },
            "style": { "doc": "$?", "names": "style" },
            "color": { "doc": "$?", "names": "color" },
            "opacity": { "doc": "$?", "names": "opacity" },
            "offset": { "doc": "$?", "names": "offset" },
            "tilt": { "doc": "$?", "names": "tilt" },
            "scale": { "doc": "$?", "names": "scale" },
            "flipx": { "doc": "$?", "names": "flipx" },
            "flipy": { "doc": "$?", "names": "flipy" }
        },
        "Color": {
            "doc": "$?",
            "names": ["🌈", "Color"],
            "lightness": { "doc": "$?", "names": ["lightness", "l"] },
            "chroma": { "doc": "$?", "names": ["chroma", "c"] },
            "hue": { "doc": "$?", "names": ["hue", "h"] }
        },
        "Sequence": {
            "doc": "$?",
            "names": ["💃", "Sequence"],
            "count": { "doc": "$?", "names": "count" },
            "timing": { "doc": "$?", "names": "timing" },
            "poses": { "doc": "$?", "names": "poses" }
        },
        "Place": {
            "doc": "$?",
            "names": ["📍", "Place"],
            "x": { "doc": "$?", "names": "x" },
            "y": { "doc": "$?", "names": "y" },
            "z": { "doc": "$?", "names": "z" }
        },
        "Stage": {
            "doc": "$?",
            "names": ["🎭", "Stage"],
            "description": "stage of $1 phrases and groups",
            "content": { "doc": "$?", "names": "content" },
            "background": { "doc": "$?", "names": "background" },
            "frame": { "doc": "$?", "names": "frame" }
        },
        "Easing": {
            "straight": "straight",
            "cautious": "cautious",
            "pokey": "pokey",
            "zippy": "zippy"
        },
        "sequence": {
            "sway": {
                "doc": "$?",
                "names": ["sway"],
                "angle": { "doc": "$?", "names": ["angle"] }
            },
            "bounce": {
                "doc": "$?",
                "names": ["bounce"],
                "height": { "doc": "$?", "names": ["height"] }
            },
            "spin": { "doc": "$?", "names": ["spin"] },
            "fadein": { "doc": "$?", "names": ["fadein"] },
            "popup": { "doc": "$?", "names": ["popup"] },
            "shake": { "doc": "$?", "names": ["shake"] }
        }
    },
    "ui": {
        "phrases": {
            "welcome": "hello",
            "motto": "Where words come to life"
        },
        "placeholders": {
            "unwritten": "TBD",
            "code": "code",
            "expression": "value",
            "type": "type",
            "percent": "percent",
            "name": "name",
            "project": "untitled",
            "email": "email"
        },
        "tooltip": {
            "yes": "confirm",
            "no": "cancel",
            "play": "evaluate the $program fully",
            "pause": "evaluate the $program one step at a time",
            "back": "back one step",
            "backInput": "back one input",
            "out": "step out of this function",
            "forward": "forward one step",
            "forwardInput": "forward one input",
            "present": "to the present",
            "start": "to the beginning",
            "reset": "restart the evaluation of the performance from the beginning.",
            "home": "return home",
            "revert": "revert to default",
            "set": "edit this property",
            "fullscreen": "fill the browser with this window",
            "collapse": "collapse window",
            "expand": "expand window",
            "close": "close this performance",
            "language": "change preferred languages",
            "horizontal": "switch to horizontal arrangement",
            "vertical": "switch to vertical arrangement",
            "freeform": "switch to free form arrangement",
            "fit": "fit to content",
            "grid": "show/hide grid",
            "addPose": "add pose",
            "removePose": "remove pose",
            "movePoseUp": "move pose up",
            "movePoseDown": "move pose down",
            "addPhrase": "add a phrase after this",
            "addGroup": "add a group after this",
            "removeContent": "remove this content",
            "moveContentUp": "move this content up",
            "moveContentDown": "move this content down",
            "editContent": "edit this content",
            "sequence": "convert to a sequence",
            "animate": "toggle animations on/off",
            "addSource": "create a new $source",
            "deleteSource": "remove this $source",
            "deleteProject": "delete this performance",
            "editProject": "edit this performance",
            "settings": "show settings",
            "newProject": "new performance",
            "dark": "toggle dark mode on, off, and default",
            "chooserExpand": "expand/collapse",
            "place": "place output",
            "paint": "paint output",
            "nextLesson": "next lesson",
            "previousLesson": "previous lesson",
            "nextLessonStep": "next step",
            "previousLessonStep": "previous step",
            "revertProject": "revert to original code"
        },
        "prompt": { "deleteSource": "delete", "deleteProject": "delete" },
        "labels": {
            "learn": "learn more …",
            "nodoc": "Who am I? What am I? What is my purpose?",
            "mixed": "mixed",
            "computed": "computed",
            "default": "default",
            "inherited": "inherited",
            "notSequence": "not a sequence",
            "notContent": "not a content list",
            "anonymous": "anonymous"
        },
        "headers": {
            "learn": "Learn",
            "select": "select a 💬, 🔳, or 🎭 to edit!",
            "editing": "edit me!",
            "projects": "Performances",
            "examples": "Examples"
        },
        "section": {
            "project": "performance",
            "conflicts": "conflicts",
            "timeline": "timeline",
            "toolbar": "toolbar",
            "output": "output",
            "palette": "palette",
            "editor": "code editor"
        },
        "feedback": {
            "unknownProject": "There's no performance with this ID."
        },
        "login": {
            "header": "Login",
            "prompt": "Log in to access your performances.",
            "anonymousPrompt": "Your performances are saved on this device. Create an account to save them online.",
            "submit": "send a login email",
            "enterEmail": "It looks like you're logging in on a different device. Can you enter your email again?",
            "sent": "Check your email for a link.",
            "success": "Account created!",
            "failure": "Couldn't reach the database",
            "expiredFailure": "This link expired.",
            "invalidFailure": "This link isn't valid.",
            "emailFailure": "This email wasn't valid.",
            "logout": "logout",
            "offline": "You appear to be offline."
        },
        "edit": {
            "before": "before $1",
            "inside": "inside $1",
            "add": "add $1",
            "append": "append $1",
            "remove": "remove $1",
            "replace": "replace with $1 ?? [$1|nothing]",
            "wrap": "parentheize",
            "unwrap": "unwrap",
            "bind": "name this expression"
        },
        "error": {
            "tutorial": "We weren't able to find a tutorial for this language."
        }
    }
}
