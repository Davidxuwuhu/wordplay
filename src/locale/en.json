{
    "$schema": "../../static/schemas/Locale.json",
    "language": "en",
    "wordplay": "Wordplay",
    "term": {
        "bind": "bind",
        "evaluate": "evaluate",
        "decide": "decide",
        "project": "performance",
        "document": "explain",
        "source": "source",
        "input": "input",
        "output": "output",
        "act": "act",
        "scene": "scene",
        "phrase": "phrase",
        "group": "group",
        "verse": "verse",
        "type": "type",
        "start": "start",
        "entered": "new",
        "changed": "changed",
        "name": "name",
        "value": "value",
        "text": "text",
        "boolean": "boolean",
        "map": "map",
        "number": "number",
        "function": "function",
        "exception": "exception",
        "table": "table",
        "none": "none",
        "list": "list",
        "stream": "stream",
        "structure": "structure",
        "streamdefinition": "stream definition",
        "index": "index",
        "query": "query",
        "row": "row",
        "set": "set",
        "key": "key"
    },
    "token": {
        "EvalOpen": "evaluation open",
        "EvalClose": "evaluation close",
        "SetOpen": "set/map open",
        "SetClose": "set/map close",
        "ListOpen": "list open",
        "ListClose": "list close",
        "TagOpen": "tag open",
        "TagClose": "tag close",
        "Bind": "bind",
        "Access": "property access",
        "Function": "function",
        "Borrow": "borrow",
        "Share": "share",
        "Convert": "convert",
        "Doc": "explanation",
        "Words": "words",
        "Link": "web link",
        "Italic": "italic",
        "Underline": "underline",
        "Light": "light",
        "Bold": "bold",
        "Extra": "extra",
        "Concept": "concept link",
        "URL": "URL",
        "ExampleOpen": "example open",
        "ExampleClose": "example close",
        "Mention": "mention",
        "Branch": "branch",
        "None": "nothing",
        "Type": "type",
        "TypeOperator": "is",
        "TypeOpen": "type input open",
        "TypeClose": "type input close",
        "Separator": "$name separator",
        "Language": "language tag",
        "BooleanType": "boolean type",
        "NumberType": "number type",
        "JapaneseNumeral": "japanese numeral",
        "RomanNumeral": "roman numeral",
        "Pi": "pi",
        "Infinity": "infinity",
        "TableOpen": "table open",
        "TableClose": "table close",
        "Select": "select",
        "Insert": "insert",
        "Update": "update",
        "Delete": "delete",
        "Union": "union",
        "Stream": "next",
        "Change": "change",
        "Initial": "first evaluation",
        "Previous": "previous",
        "Placeholder": "placeholder",
        "Etc": "et cetera",
        "This": "this",
        "Operator": "operator",
        "Conditional": "conditional",
        "Text": "text",
        "TemplateOpen": "template open",
        "TemplateBetween": "template between",
        "TemplateClose": "template close",
        "Number": "number",
        "Decimal": "decimal numeral",
        "Base": "base numeral",
        "Boolean": "boolean",
        "Name": "name",
        "Unknown": "unknown",
        "End": "end"
    },
    "node": {
        "Dimension": {
            "name": "dimension",
            "description": "dimension",
            "emotion": "serious",
            "doc": [
                "I am a /unit of measurement/!",
                "I can be any standardized units, like ⧼1m⧽, ⧼10s⧽, ⧼100g⧽, or any other scientific unit. I'm happy to be any unit want to make up too, like ⧼17apple⧽.",
                "I can be combined with ⧼/⧽ to make ratio units like ⧼17apple/day⧽ and with ⧼^⧽ to make exponentional units like ⧼9.8m/s^2⧽",
                "I must always come after a @Number. If I don't, I might be mistaken for @Reference, which would be quite embarassing!",
                "I'm pretty good at finding inconsistencies between units too. For example, ⧼1cat + 1dog⧽ doesn't make any sense!",
                "If you ever want to convert between different values of units, go talk to @Convert."
            ]
        },
        "Doc": {
            "name": "explanation",
            "emotion": "serious",
            "doc": [
                "I describe the purpose of code.",
                "I can go before any expression:",
                "⧼1 - `Is this really supposed to be 7?`7⧽",
                "For example, you can place me before @Bind:",
                "⧼`I measure how tall someone is`\nheight: 5m⧽",
                "Or before a @FunctionDefinition:",
                "⧼`I add two numbers`\nƒ sum(a•# b•#) a + b⧽",
                "Or before a @StructureDefinition:",
                "⧼`I remember people's name and favorite fruit`\n•Person(name•'' fruit•'')⧽",
                "You can also place me at the very beginning of @Program to say what the whole performance is about",
                "⧼`This program says hello`\n\n'hello!'⧽",
                "You can give me a @Language to help others know what language I'm written in:",
                "⧼`I'm an English doc`/en\nduration: 5s⧽",
                "Did you know you can make a list of me? Go talk to @Docs."
            ]
        },
        "Docs": {
            "name": "explanation list",
            "emotion": "serious",
            "doc": [
                "I'm a list of @Doc, useful when you have multiple translations of @Doc in different languages.",
                "You don't have to do anything special to make a list. Just put a bunch of @Doc next to each other, like this:",
                "⧼`Hello`/en\n`Hola`/es\ngreeting: '…'⧽"
            ]
        },
        "KeyValue": {
            "name": "mapping",
            "emotion": "kind",
            "doc": [
                "I'm a mapping from a *key* to a *value*, always in a @Map.",
                "You can map any kind of value to any other. For example, here's a mappning of numbers:",
                "⧼{1:1}⧽",
                "Or a mapping from text to numbers:",
                "⧼{'bunny':1}⧽"
            ]
        },
        "Language": {
            "name": "language",
            "description": "language $1[$1|unknown]",
            "emotion": "eager",
            "doc": [
                "I'm a language tag and I work with @Name and @Doc!",
                "I'm really good at making it *crystal clear* what lanugage something is written in.",
                "That's what I do. Just a little slash, and a couple letters, and no one will ever be confused about what language some text is in.",
                "For example, let's say you wanted to say my $name, but make it clear I'm in English:",
                "⧼\"Language\"/en⧽",
                "Or, suppose you wanted to do this for a @Name.",
                "⧼sound/en: 'meow'⧽",
                "Or even @Doc!",
                "⧼`Onomatopoeia`/en\nsound/en: \"meow\"⧽",
                "There are many <2-letter language codes@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> that I understand. If you don't use one of those, I'll let you know."
            ],
            "conflict": {
                "UnknownLanguage": "I don't know this language",
                "MissingLanguage": "I'm missing a language. Can you add one?"
            }
        },
        "Name": {
            "name": "name",
            "description": "$1[$1 | unnamed]",
            "emotion": "kind",
            "doc": [
                "I identify a value, and am a helpful way of giving a shorthand label to something that was hard to evaluate, or that you don't want to have to evaluate over and over.",
                "@Bind gives me my name like this:",
                "⧼hi: 5⧽",
                "I only ever represent one value, and once I have it, I can't change. For example, if you tried to do this with @Bind, we would complain.",
                "⧼hi: 5\nhi: 3⧽",
                "All you have to do to get my value is have @Reference or @PropertyReference use name. Here, @Bind names me, then @Reference get the value I was given.",
                "⧼hi: 5\nhi⧽",
                "Because @Bind can show up in so many places, I can show up in many places. I was in a @Block above, but I can be in a @FunctionDefinition. Here I am naming a message temporarily:",
                "⧼ƒ say(message•'') message⧽",
                "I get defined inside @FunctionDefinition, and then as soon as the function is done evaluating, I go away.",
                "You can use @Language to indicate what language my name is in. This is helpful when sharing your performance with others, in case they want to read your program."
            ]
        },
        "Names": {
            "name": "name list",
            "emotion": "kind",
            "doc": [
                "I'm a list of @Name, useful when you want to give a value multiple names, often with different @Language.",
                "Names are separated by ⧼,⧽ symbols. For example, here's @Bind giving a value multiple @Name",
                "⧼hi/en,hello/en,hola/es: 'welcome'⧽"
            ]
        },
        "Row": {
            "name": "row",
            "emotion": "angry",
            "doc": "$? Row",
            "conflict": {
                "InvalidRow": "I'm missing one or more columns",
                "MissingCell": {
                    "primary": "I'm missing column $1",
                    "secondary": "I'm required, but $2 didn't provide it"
                },
                "UnknownColumn": "I don't know a column by this name"
            }
        },
        "Token": {
            "name": "token",
            "description": "$1 $2",
            "emotion": "neutral",
            "doc": [
                "How did you find me?",
                "I am the smallest possible part of a performance. I am the substrate from which all characters in the Verse are made. I am the atomic particle of our choreography."
            ]
        },
        "TypeInputs": {
            "name": "type inputs",
            "emotion": "curious",
            "doc": "I am a list of types that take the place of @TypeVariables in a @StructureDefinition or @FunctionDefinition. I help everyone know what kind of inputs they'll be receiving."
        },
        "TypeVariable": {
            "name": "type variable",
            "emotion": "curious",
            "doc": "I am a mystery type on @FunctionDefinition or @StructureDefinition, provided by @TypeInputs when either is evaluated. @Set, @List, and @Map use me.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "I have the same name as $1",
                    "secondary": "I have the same name as $1"
                }
            }
        },
        "TypeVariables": {
            "name": "type variables",
            "emotion": "curious",
            "doc": "I am a list of @TypeVariable."
        },
        "Markup": {
            "name": "markup",
            "description": "$1 paragraphs",
            "emotion": "serious",
            "doc": [
                "I'm a list of paragraphs, using the many kinds of markup available in explanations, such as @Words, @WebLink, @ConceptLink, and @Example."
            ]
        },
        "Paragraph": {
            "name": "paragraph",
            "emotion": "serious",
            "doc": [
                "I'm a series of @Words, @ConceptLink, @WebLink, and @Example, separated by a blank line, and inside @Doc.",
                "All you need to do to write me is write a bunch of words in a @Doc:",
                "⧼`I am a paragraph in a doc.`'one paragraph'⧽",
                "If you want multiple paragraphs, just put in blank lines.",
                "⧼`Paragraph 1.\n\nParagraph 2.\n\nParagraph 3.`'three paragraphs'⧽"
            ]
        },
        "WebLink": {
            "name": "link",
            "description": "link $1",
            "emotion": "serious",
            "doc": [
                "I am a link to something on the internet. I just need a description and a URL:",
                "⧼`I am a <link@https://wordplay.dev> in a doc`\n'link example'⧽",
                "If anyone selects me, I'll open a new window to the URL."
            ]
        },
        "ConceptLink": {
            "name": "concept",
            "description": "concept $1",
            "emotion": "serious",
            "doc": [
                "I'm a link to Verse character. I'm helpful when you want to write a @Doc and refer to one of us.",
                "For example, say you wanted to talk about @Evaluate, and how awesome they are. You could write:",
                "⧼`You know, @Evaluate is pretty awesome.`\n'look, a concept link!'⧽",
                "When the @Doc you wrote appears here, it'll show a link to the concept."
            ]
        },
        "Words": {
            "name": "words",
            "emotion": "serious",
            "doc": [
                "I'm any words you like in a @Doc. For example:",
                "⧼`May the Force be with you.`\n'just some words!'⧽",
                "Sometimes though, you might want to use the special characters that @Doc uses /as/ words. For example:",
                "⧼`My friends use @@, //, **, ||, and other symbols.`\n'using special characters!'⧽",
                "If you just repeat those special characters, you'll get the character instead of their special meaning."
            ]
        },
        "Example": {
            "name": "example",
            "emotion": "serious",
            "doc": [
                "I'm an example performance, helpful for writing @Doc that explains how to use something!",
                "⧼`Here's an example of adding: ⧼1 + 1⧽`'example code'⧽",
                "If you put me in a paragraph all alone, I'll show up in a fancy box and show the result of evaluating me.",
                "⧼`Here's an example of adding:\n\n⧼1 + 1⧽`⧽"
            ]
        },
        "Mention": {
            "name": "mention",
            "description": "mention $1",
            "emotion": "serious",
            "doc": [
                "I'm a reference to either terminology ⧼$program⧽ or a dynamic input ⧼$1⧽.",
                "This is mostly an internal feature though, so you shouldn't need to know it."
            ]
        },
        "Branch": {
            "name": "branch",
            "emotion": "serious",
            "doc": [
                "I'm a way of choosing between two segments of explanation based on whether a explanation input value is defined or true.",
                "This is mostly an internal feature though, so you shouldn't need to know it."
            ]
        },
        "BinaryEvaluate": {
            "name": "binary operation",
            "description": "$1 operation",
            "emotion": "insecure",
            "doc": [
                "I'm @Evaluate, but in a simpler form, helpful when you want to use a @FunctionDefinition that takes two inputs.",
                "For example, here's how you might use @Evaluate to add two numbers:",
                "⧼1.+(1)⧽",
                "Doesn't that look a little funny? It's not wrong: it just says get the add function on 1 and then evaluate it.",
                "But it's much easier to use @BinaryEvaluate",
                "⧼1 + 1⧽",
                "This makes everythign a bit tidier, even though its basically the same thing.",
                "There's only one thing to watch out for: when I'm in this form, I evaluate from left to right. That might be confusing if you're used to things like order of operations in mathematics.",
                "It means that this evaluates in a way that you might not expect:",
                "⧼1 + 2 · 3 + 4⧽",
                "In math, multiplication would come first, and then addition, and so the result would be ⧼11⧽. But since I evaluate in reading order, the result is ⧼13⧽."
            ],
            "right": "input",
            "start": "let's evaluate $1 first",
            "finish": "look, I made $1!",
            "conflict": {
                "OrderOfOperations": "I evalute in reading order, not in math order of operations. Do you want to use @Block to specify the order I should evaluate in?"
            }
        },
        "Bind": {
            "name": "bind",
            "description": "bind $1",
            "emotion": "excited",
            "doc": [
                "I name *values*.",
                "Like this!",
                "⧼pi: 3.1415926⧽",
                "I name inputs to @FunctionDefinition and @StructureDefinition, I name values in @Block. I name everything!",
                "Oh, but did you know you can have one value *many names*?",
                "I'm so excited to tell you about this! One value, many @Names. For example:",
                "⧼joe,tess,amy: 5⧽",
                "See what I did there? ",
                "One value, three names.",
                "You can refer to that five by *any* of those names.",
                "This is especially when you want to give names in many languages:",
                "⧼joe/en,aimee/fr,明/zh: 5⧽",
                "See what I did there? Three names for one value, just in different languages!",
                "Okay, I have one last secret.",
                "Did you know I can work with @Is to tell me what kind of value a name should have? And if I doesn't have it, I will tell you?",
                "Like this:",
                "⧼bignumber•#: \"one zillion\"⧽",
                "See, I said ⧼bignumber⧽ should be a number, but it's text, and those aren't compatible and so BOOM!",
                "I'll let you know if they disagree.",
                "Sometimes you might *have* to tell me what kind of data something else because I can't figure it out myself. That usually happens in @FunctionDefinition.",
                "For example, here, @FunctionDefinition doesn't know what what kind of values ⧼a⧽ and ⧼b⧽ have, because I didn't tell them.",
                "⧼ƒ sum(a b) a + b⧽",
                "But we can change this to add the @Is, and now @FunctionDefinition knows that they're numbers:",
                "⧼ƒ sum(a•# b•#) a + b⧽"
            ],
            "start": "let's see what value we get from $1!",
            "finish": "oh nice, I got $1! Let's name it $2",
            "conflict": {
                "DuplicateName": {
                    "primary": "someone has the name $1, so I can't have this name.",
                    "secondary": "uh, $1 is my name"
                },
                "DuplicateShare": {
                    "primary": "I have the same name as $1, which makes what is shared ambiguous",
                    "secondary": "I have has the same name as $1"
                },
                "IncompatibleType": {
                    "primary": "I'm supposed to be $2, but I'm $1",
                    "secondary": "hey, I got a $2 instead of a $1"
                },
                "MisplacedShare": "I can only share things at the @Program level, not inside anything!",
                "MissingShareLanguages": "if you want to share this, you have to say what language this is in, so others know if they can read it!",
                "RequiredAfterOptional": "I can't be here, there's an optional @Bind before me",
                "UnexpectedEtc": "I can only be variable length in a @FunctionDefinition",
                "UnusedBind": "hey, I named this value, but no one is using it!"
            }
        },
        "Block": {
            "name": "block",
            "description": "$1 statements",
            "emotion": "shy",
            "doc": [
                "Hi. I make a little quiet, private space for evaluate things.",
                "Like this:",
                "⧼(1 - 1) + 2⧽",
                "That helps clarify order of evaluation.",
                "@Bind helps too.",
                "⧼(count: 10 count ^ count)⧽",
                "See how @Bind made ⧼count⧽? It's only named inside me. So this won't work:",
                "⧼(count: 10 count ^ count) + count⧽",
                "Because count was only named inside me.",
                "You can put as many expressions as you like in me. But I only care about the last:",
                "⧼(1 2 3 4 5)⧽",
                "So usually I'm just a bunch of @Bind and then an expression at the end.",
                "⧼(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)⧽"
            ],
            "statement": "statement",
            "start": "first expression",
            "finish": "done, I got $1",
            "conflict": {
                "ExpectedEndingExpression": "I need an expression.",
                "IgnoredExpression": {
                    "primary": "I'm going to ignore the above.",
                    "secondary": "@Block, don't ignore me!"
                }
            }
        },
        "BooleanLiteral": {
            "name": "boolean",
            "description": "$1[true|false]",
            "emotion": "precise",
            "doc": "See @Boolean.",
            "start": "$1!"
        },
        "Borrow": {
            "name": "borrow",
            "description": "borrow $1[$1|missing name]",
            "emotion": "excited",
            "doc": "If you create a performance with multiple @Source, you can use me to borrow @Bind that are shared in those other @Source. Just use their name and I'll bring in their name and value.",
            "start": "borrowing $2 from $1",
            "source": "$source",
            "bind": "name",
            "version": "version",
            "conflict": {
                "UnknownBorrow": "I don't know a $source by this name",
                "BorrowCycle": "this depends on $1, which depends on this $source, so the program can't be evaluated"
            },
            "exception": {
                "CycleException": {
                    "description": "borrow cycle",
                    "explanation": "$1 depends on itself"
                }
            }
        },
        "Changed": {
            "name": "changed",
            "emotion": "serious",
            "doc": [
                "I check if a stream caused @Program to reevaluate, and make a @Boolean. Like this",
                "⧼∆ Time()⧽",
                "I'm really helpful when you want something to change only if a stream changed.",
                "That's it."
            ],
            "start": "let's see if $1 changed…"
        },
        "Conditional": {
            "name": "conditional",
            "emotion": "curious",
            "doc": [
                "I think I'm supposed to make decisions? Like this?",
                "⧼number: -100\nnumber < 0 ? 'negative' 'positive'⧽",
                "But have you ever thought about how we decide?",
                "Doesn't it seem like decisions should be more nuanced than just yes or no? Is deciding between ⧼⊤⧽ and ⧼⊥⧽ all there is?",
                "Aren't you worried that if these are the only kind of decisions we can make, we'll be missing some important context about the world?"
            ],
            "start": "let's see if $1 is true",
            "else": "$1[jumping over code | not jumping over code]",
            "afterthen": "done with yes, let's skip no?",
            "finish": "I guess it's $1?",
            "condition": "condition",
            "yes": "yes",
            "no": "no",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "How can I choose yes and no with a $1? No really, how?",
                    "secondary": "I think @Conditional wanted me to be a @Boolean, but I'm a $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "conversion definition",
            "description": "$1 → $2",
            "emotion": "excited",
            "doc": [
                "Dude, I define conversions from one type to another! I go in @Block, someting like this:",
                "⧼→ #kitty #cat . ÷ 2\n6kitty→#cat⧽",
                "See how I turned kitties into cats? Wicked!",
                "You might be wondering what that ⧼.⧽ is doing there. That represents the value being converted. I use that because the value has no name otherwise."
            ],
            "start": "awesome, a new conversion!",
            "conflict": {
                "MisplacedConversion": "whoa, I can't be here, just in @Block."
            }
        },
        "Convert": {
            "name": "convert",
            "emotion": "cheerful",
            "doc": [
                "Yo. I turn values from one type to another. Check it out:",
                "⧼1 → \"\"⧽",
                "⧼5s → #ms⧽",
                "⧼\"hello\" → []⧽",
                "You can even chain these together:",
                "⧼\"hello\" → [] → {}⧽",
                "Values have a set of @ConversionDefinition that are predefined, but if you make a @StructureDefinition for a new type of value, you can define your own with @ConversionDefinition."
            ],
            "start": "get that value from $1!",
            "finish": "Awesome, I made $1",
            "conflict": {
                "UnknownConversion": "Bummer, no way make $1 into $2"
            },
            "exception": {
                "ConversionException": {
                    "description": "impossible conversion",
                    "explanation": "I don't know how to convert from $1 to $2"
                }
            }
        },
        "Delete": {
            "name": "delete",
            "emotion": "angry",
            "doc": "$? Delete",
            "start": "evaluate $1 first",
            "finish": "evaluated to table without row $1"
        },
        "DocumentedExpression": {
            "name": "explained expression",
            "emotion": "eager",
            "doc": [
                "I'm any expression, but with a @Doc!",
                "To make me, just put a @Doc before an expression, and you'll get me:",
                "⧼doubleplus: 1\n(2 · doubleplus) + \n`Let's make it just a little bit bigger`\n1⧽",
                "I'm useful for making a comment on some part of a program."
            ],
            "start": "let's evaluate the expression"
        },
        "Evaluate": {
            "name": "evaluate",
            "description": "evaluate $1[$1|anonymous]",
            "emotion": "shy",
            "doc": [
                "Hi. I evaluate my dearest @FunctionDefinition. Like this:",
                "⧼ƒ greeting(message•'')\ngreeting('kitty')⧽",
                "Functions can come from anywhere. For example, @Text has functions. Like this:",
                "⧼'kitty'.length()⧽",
                "If a function has a single symbol name, you can write me as a @BinaryEvaluate.",
                "⧼'kitty' ⊆ 'itty'⧽",
                "That does the same thing as this:",
                "⧼'kitty'.⊆('itty')⧽",
                "Of course, I'm nothing without @FunctionDefinition. All I do is give inputs to them and then follow their steps."
            ],
            "start": "let's evaluate the inputs first",
            "evaluate": "let's evaluate the function now",
            "finish": "I evaluated to $1",
            "function": "function",
            "input": "input",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "I'm supposed to be a $1, but I'm a $2",
                    "secondary": "Umm, I got a $2 instead of a $1"
                },
                "UnexpectedTypeInput": {
                    "primary": "I wasn't expecting this type input",
                    "secondary": "oh, am I not supposed to be here?"
                },
                "MisplacedInput": "this input is out of order.",
                "MissingInput": {
                    "primary": "I missing $1, can you add it?",
                    "secondary": "this input is required, but $2 didn't provide it"
                },
                "NotInstantiable": "I can't make this @StructureDefinition, it has unimplemented functions.",
                "UnexpectedInput": {
                    "primary": "I didn't expect this input $1",
                    "secondary": "Oh, am I not supposed to be here?"
                },
                "UnknownInput": {
                    "primary": "I don't know of an input by this name",
                    "secondary": "I don't think I belong here"
                },
                "InputListMustBeLast": "list of inputs must be last"
            },
            "exception": {
                "FunctionException": {
                    "description": "unknown function",
                    "explanation": "oh no, $1 isn't a function in $2[$2|this @Block]!"
                }
            }
        },
        "ExpressionPlaceholder": {
            "name": "placeholder",
            "description": "$1[$1|placeholder]",
            "emotion": "scared",
            "doc": [
                "I'm an *expression*, but not a real one… I just take the place of one.",
                "I'm good if you don't know what to write yet. Like this:",
                "⧼1 + _⧽",
                "What are we adding? I don't know. You tell me.",
                "Or if someone was evaluating a function with @Evaluate, I might stand in for the function",
                "⧼_(1 2 3)⧽",
                "I don't like being on @Stage!"
            ],
            "start": "eek, I don't know what to do!",
            "placeholder": "expression",
            "conflict": {
                "Placeholder": "can someone take my place?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "unimplemented",
                    "explanation": "I don't know what to do!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "function",
            "description": "function $1",
            "emotion": "kind",
            "doc": [
                "Hi again! I take some inputs, then evaluate an expression using them, producing an output.",
                "Here's a simple example:",
                "⧼ƒ repeat(message•'') message · 5\nrepeat('hi')⧽",
                "That function takes one input, ⧼message⧽, and uses the @Text/repeat function to repeat the message five times.",
                "I'm really helpful if you want to evaluate something over and over, but with different inputs!",
                "I do have lots of other little tricks. For example, I don't have to have a name. Here, I'm just going directly to @Evaluate as a value.",
                "⧼(ƒ(message•'') message · 5)('hi')⧽",
                "Or, here's a function that takes any number of inputs, using the ⧼…⧽ character after an input name.",
                "⧼ƒ yes(messages…•'') messages.sans('no')\nyes('yes' 'yes' 'no' 'yes' 'no')⧽",
                "See how it took all the 'no's and got rid of them? That's because messages is a @List, and so we could use @List/sansAll.",
                "Sometimes you might want to make it clear what kind of value I produce. To do that, add an @Is after the list of inputs:",
                "⧼ƒ add(x•# y•#)•'' x + y⧽",
                "You might notice a problem with this one: it says it evaluates to @Text, but it takes two @Number. I can tell you when things are inconsistent!",
                "Of course, I'm not really useful at all without @Evaluate; they bring me to life."
            ],
            "start": "let's make this function!",
            "conflict": {
                "NoExpression": "I need an expression to evaluate, can you add one?"
            }
        },
        "HOF": {
            "name": "higher order function",
            "emotion": "kind",
            "doc": "I'm a very special kind of @FunctionDefinition that operates on lists of things. You don't need to know anything about me, other than I make functions like @List/translate possible. ",
            "start": "evaluating the function given",
            "initialize": "preparing to step through items",
            "next": "applying the function to the next item",
            "check": "deciding whether to continue",
            "finish": "I evaluated to $1"
        },
        "Initial": {
            "name": "start",
            "emotion": "curious",
            "doc": [
                "I tell you whether the current evaluation of @Program is the first one, evaluating to a @Boolean. For example:",
                "⧼◆ ? Time() 'hi'⧽",
                "You didn't see it, but the first evaluation was a time, but then all future time ticks, I was ⧼⊥⧽, so @Conditional made ⧼⊤⧽.",
                "I'm really helpful if you're working with a stream and you only want to do something the first time -- or never on the first time!"
            ]
        },
        "Insert": {
            "name": "insert",
            "emotion": "angry",
            "doc": "$? Insert",
            "start": "evaluate $1 first",
            "finish": "evaluated to table new rows, $1"
        },
        "Is": {
            "name": "is",
            "description": "is",
            "emotion": "curious",
            "doc": [
                "You know what? There are so many kinds of values that mean so many different things. I help figure out what they are.",
                "For example, suppose you had a mystery value. I can tell you whether it's a @Number, giving you a @Boolean:",
                "⧼mystery: 'secret!'\nmystery•#⧽",
                "It's not a number, so I made ⧼⊥⧽. But if we check if it's @TextType?",
                "⧼mystery: 'secret!'\nmystery•''⧽",
                "We get ⧼⊤⧽!",
                "I'm really helpful when you need to know whether some @Name has a value of a particular kind."
            ],
            "start": "let's get the value of $1 first",
            "finish": "$1[value is $2|value is not $2]",
            "conflict": {
                "ImpossibleType": "this can't ever be this type"
            },
            "exception": {
                "TypeException": {
                    "description": "incompatible values",
                    "explanation": "I expected a $1 but received $2"
                }
            }
        },
        "ListAccess": {
            "name": "list access",
            "emotion": "cheerful",
            "doc": [
                "I work closely with @List to help them get values at a particular position. So like, if you had a list, and you wanted its second item, you'd write:",
                "⧼list: ['bird' 'duck' 'fish' 'snake']\nlist[2]⧽"
            ],
            "start": "let's get the list $1 first",
            "finish": "the item is $2!"
        },
        "ListLiteral": {
            "name": "list",
            "description": "$1 item list",
            "emotion": "eager",
            "doc": "See @List.",
            "start": "let's evaluate the items first",
            "finish": "I made a me! $1",
            "item": "item"
        },
        "MapLiteral": {
            "name": "map",
            "description": "$1 pairing map",
            "emotion": "kind",
            "doc": "See @Map.",
            "start": "let's evaluate the keys and values first",
            "finish": "I connected everyone, $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "one of my keys is missing a value",
                    "secondary": "oops, where's my value?"
                }
            }
        },
        "NumberLiteral": {
            "name": "number",
            "description": "$1 $2",
            "emotion": "excited",
            "doc": "See @Number.",
            "start": "$1!",
            "conflict": {
                "NotANumber": "I thought I knew all the numbers, but I don't know this one"
            }
        },
        "NativeExpression": {
            "name": "internal expression",
            "emotion": "neutral",
            "doc": "How did you find me? I'm an expression that only the original creators use. To learn more about me, you'll need to talk to them.",
            "start": "secret expression"
        },
        "NoneLiteral": {
            "name": "none",
            "emotion": "neutral",
            "doc": "See @None.",
            "start": "… ø"
        },
        "Previous": {
            "name": "previous",
            "emotion": "serious",
            "doc": [
                "Have you ever wanted to remember the past?",
                "I am the Verse's official record keeper. Give me a stream and a number to look backwards and I'll tell you what that stream's value was in history.",
                "For example, here's what @Time it was five ticks ago:",
                "⧼Time(1000ms)←5⧽",
                "See how it's @None for 5 seconds, then suddenly a previous time?",
                "I'm helpful when you want to create performances that depend on the past."
            ],
            "start": "first get $1",
            "finish": "evaluated to stream value $1"
        },
        "Program": {
            "name": "program",
            "emotion": "serious",
            "doc": [
                "I'm where a performance begins and ends, containing all of the other characters that choregraph a show.",
                "You know how @Block evaluates a list of expressions, and evaluates to the last one in its list? ",
                "I'm the same, but rather than giving my value to whatever expression I'm in, I put the value on @Stage.",
                "The value can be anything: a @Number, @Text, or @Boolean, a @List, @Set, @Map, or even something more complex, like a @Phrase, @Group, or @Stage.",
                "If you don't give me a value to show on stage, I'll ask you for one.",
                "If there's a problem during a performance, I'll show that problem.",
                "And if your performance depends on a *stream*, I'll reevaluate every time that stream changes."
            ],
            "unevaluated": "the node you chose didn't evaluate",
            "start": "$1[a stream changed!|it's my first evaluation]",
            "halt": "encountered exception, stopping",
            "finish": "all done, I evaluated to $1",
            "done": "there's nothing evaluating",
            "exception": {
                "BlankException": {
                    "description": "empty program",
                    "explanation": "Let's put on a show! Where should we start?"
                },
                "EvaluationLimitException": {
                    "description": "evaluation limit",
                    "explanation": "@Evaluate and I are tired of evaluating, especially $1.\n\nIs it possible that $1 is evaluating itself forever, without ever stopping?"
                },
                "StepLimitException": {
                    "description": "step limit",
                    "explanation": "there are so. many. steps -- too many to finish! Can you make the performance simpler?"
                },
                "ValueException": {
                    "description": "missing value",
                    "explanation": "oh no, someone excepted a value but didn't get one…"
                }
            }
        },
        "PropertyBind": {
            "name": "refine",
            "description": "refine $1[$1|missing name]",
            "emotion": "kind",
            "doc": [
                "Sometimes when you make a @StructureDefinition, you want to change the tiniest thing about it, without having to make a new one with all the same values.",
                "For example, what if you were keeping a record of cats, but then wanted to create a copy of a cat with a different hobby? I can help you change it:",
                "⧼•Cat(name•'' color•'' hobby•'')\n\nkitty: Cat('sprinkles' 'orange' 'licking')\nkitty.hobby:'purring'⧽",
                "That's so much easier than making a whole new ⧼Cat⧽ with the same values except for the hobby, isn't it?"
            ],
            "start": "first let's get the value",
            "finish": "I copied the structure, but with $1 as $2"
        },
        "PropertyReference": {
            "name": "property",
            "description": "property $1[$1|missing name]",
            "emotion": "kind",
            "doc": [
                "When you make a @StructureDefinition, how do you get one of its inputs? I'm how",
                "Like if you had a structure about cities, you could get its values with me like this:",
                "⧼•City(name•'' population•#people)\n\nportland: City('Portland' 800000people)\n\nportland.population⧽"
            ],
            "start": "first let's get the value",
            "finish": "found property $1, it is $2",
            "property": "property"
        },
        "Reaction": {
            "name": "reaction",
            "emotion": "excited",
            "doc": [
                "Streams are so awesome! I can make new ones based on when they change, which is super cool!",
                "Like, if you wanted @Time to tick, but like, to show words instead of numbers, you could do something like this:",
                "⧼time: Time(1000ms)\n'start' … ∆ time … ((time % 2) = 0ms) ? 'even' 'odd'⧽",
                "That's like saying \"/begin with the word 'start' and then if time changes, change to either even or odd, based on the time./\"",
                "So I'm like a stream to, but one based on other streams. Wicked, huh?"
            ],
            "start": "let's see if we should update the stream",
            "finish": "the new stream value is $1",
            "initial": "initial",
            "condition": "condition",
            "next": "next",
            "conflict": {
                "ExpectedStream": "$1 doesn't reference a stream, so I will never react!"
            }
        },
        "Reference": {
            "name": "reference",
            "description": "$1",
            "emotion": "shy",
            "doc": [
                "You know how @Bind gives things @Name? I'm how you refer to them. I see if any @Bind has that name, if so, give you its value. Like this:",
                "⧼parrot: 'polly'\nparrot⧽",
                "If I don't find the name, then I don't know what to do.",
                "⧼parrot: 'polly'\nperry⧽"
            ],
            "start": "what value does $1 have?",
            "conflict": {
                "UnknownName": "$1[I don't know anyone named $1 in $2[$2|this @Block]|Can you give me a name?]",
                "ReferenceCycle": "um, $1's value depends on itself, so how do I know what value to give it?",
                "UnexpectedTypeVariable": "I don't now what to do with these type inputs"
            },
            "exception": {
                "NameException": {
                    "description": "unknown name",
                    "explanation": "$1[I don't know anyone named $1 in $2[$2|this @Block]…|Eep, no name!]"
                }
            }
        },
        "Select": {
            "name": "select",
            "emotion": "angry",
            "doc": "$? Select",
            "start": "evaluate $1 first",
            "finish": "evaluated to a new table with the selected rows, $1",
            "conflict": {
                "ExpectedSelectName": "I need at least one column name."
            }
        },
        "SetLiteral": {
            "name": "set",
            "description": "$1 items",
            "emotion": "eager",
            "doc": "See @Set.",
            "start": "let's evaluate the values first!",
            "finish": "I made a set $1!"
        },
        "SetOrMapAccess": {
            "name": "set/map access",
            "emotion": "kind",
            "doc": [
                "I can see if a @Set or @Map has a value or key.",
                "It's not too hard. Like this:",
                "⧼faves: {'duck' 'goose' 'monkey'}\nfaves{'mouse'}⧽",
                "Or this, with a @Map:",
                "⧼faves: {'mac and cheese': 5stars 'cereal': 2stars 'gruel': 1stars}\nfaves{'gruel'}⧽"
            ],
            "start": "what's the set or map?",
            "finish": "the value is $1",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "I expected a $1 key",
                    "secondary": "I got a $1 instead of a $2"
                }
            }
        },
        "Source": {
            "name": "source",
            "emotion": "curious",
            "doc": [
                "Oh, you know @Program? I help you name them. Think of me like the window around a @Program, and the name you give them.",
                "You can also make other @Source @UI/addSource, with other @Program, and @Borrow things from those other @Program for use in another program.",
                "This can be a nice way of organizing a big performance into separate documents."
            ]
        },
        "StreamDefinition": {
            "name": "stream",
            "emotion": "curious",
            "doc": "I /think/ I'm supposed make new streams. But I really don't know ho to do that. For now, I guess just use the streams that exist?",
            "start": "create this new kind of stream"
        },
        "StructureDefinition": {
            "name": "structure",
            "description": "structure $1",
            "emotion": "kind",
            "doc": [
                "Why hello, how are you? Me? I'm great. I love to define structures that store values and function, so as long as I get to do that all day, I'm happy.",
                "I work like this:",
                "⧼•Pizza(\ningredients•['']\nsize•#in\n) (\n\tƒ cost() size · 10dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost()⧽",
                "See how that works? I defined ⧼Pizza⧽, which has two inputs, ⧼ingredients⧽ (a list of @Text) and ⧼size⧽ (a number in inches).",
                "Inside, @FunctionDefinition made a function that evaluates the cost of a pizza, assuming $$10 per inch.",
                "I don't need to have @FunctionDefinition in me. I can just be inputs.",
                "⧼•Pizza(\ningredients•['']\nsize•#in\n)⧽",
                "I can also have @Bind inside, so we could evaluate the cost in advance.",
                "⧼•Pizza(\ningredients•['']\nsize•#in\n) (\n\tcost: size · 10dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost⧽"
            ],
            "start": "let's define this lovely structure",
            "conflict": {
                "DisallowedInputs": "I can't have inputs because one of or more of my interface functions isn't implemented",
                "IncompleteImplementation": "my functions either need to all be implemented, or none be implemented. No messy mixtures!",
                "NotAnInterface": "I am not an interface; a structure can only implement interfaces, not other structures",
                "UnimplementedInterface": "I implement $1 but haven't implemented $2"
            }
        },
        "TableLiteral": {
            "name": "table",
            "description": "$1 row table",
            "emotion": "angry",
            "doc": "See Table.",
            "item": "row",
            "start": "first evaluate the rows",
            "finish": "evaluated to new table $1"
        },
        "Template": {
            "name": "template",
            "emotion": "serious",
            "doc": [
                "I can be placed inside @Text to combine text and other values into a larger text value.",
                "For instance, consider this:",
                "⧼\"Here are some sums \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"⧽",
                "See how elegantly I just evaluated those sums, and placed them inside the @Text?",
                "I'm very helpful when you want to combine some @Text and other values."
            ],
            "start": "let us evaluate each expression in the text",
            "finish": "let us combine the text"
        },
        "TextLiteral": {
            "name": "text",
            "description": "text $1",
            "emotion": "serious",
            "doc": "See @Text?",
            "start": "let's make text"
        },
        "This": {
            "name": "this",
            "emotion": "serious",
            "doc": [
                "Sometimes, it's helpful to refer to a value implicilty, rather than having to name it.",
                "For example, suppose you wanted to make a new @ConversionDefinition, which doesn't name the value being convered. You can just refer to it with me:",
                "⧼→ #rainbows #joys . · 1000000joys\n2rainbows → #joys⧽",
                "See me there, representing the number of rainbows?",
                "Or suppose you wanted to make a @Reaction, but not have to name the most recent value:",
                "⧼2 … ∆ Time(1000ms) … . · 2⧽",
                "Check me out, representing the previous reaction value.",
                "I don't show up often, but when I do, I can really help a value get out of a @Bind!"
            ],
            "start": "evaluated to $1",
            "conflict": {
                "MisplacedThis": "I'm only allowed in a structure, conversion, or reaction."
            }
        },
        "UnaryEvaluate": {
            "name": "unary operation",
            "description": "$1",
            "emotion": "kind",
            "doc": [
                "Did you know that when I'm evaluating a @FunctionDefinition with just one value, and the name of the @FunctionDefinition is just a single symbol, you can put the name before the input?",
                "Like this:",
                "⧼-(1 + 1)⧽",
                "Or this:",
                "⧼~⊥⧽",
                "Those are much easier to read than ⧼(1 + 1).negate()⧽ or ⧼⊥.not()⧽, aren't they?",
                "You don't have to write me that way, but it might be easier overall.",
                "There's only one rule: you can't put any space between the name and the value. Otherwise you might be making a @Reference or @BinaryEvaluate."
            ],
            "start": "what's the value?",
            "finish": "I made it $1"
        },
        "UnparsableExpression": {
            "name": "unparsable",
            "emotion": "excited",
            "doc": [
                "/Hi @FunctionDefinition here. I'm translating for @UnparsableExpression, since they're often hard to interpret./",
                "jkwel fjiwojvioao jjiweo jrfe",
                "/Not every expression has meaning on stage./",
                "s w ieorjwei iojwi jfkdlsfdsk",
                "/In fact, there are all kinds of things you can say that don't make any sense at all./",
                "dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "/When you do, I show up, because I don't know what you meant./",
                "You are the director after all, so only you know what you might have meant!"
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": "@FunctionDefinition here, @UnparsableExpression doesn't know what kind of $1[ expression | type ] this is/",
                "UnclosedDelimiter": "I expected $2 sometime after $1"
            },
            "exception": {
                "UnparsableException": {
                    "description": "???",
                    "explanation": "???"
                }
            }
        },
        "Update": {
            "name": "update rows",
            "emotion": "angry",
            "doc": "$? Update",
            "start": "evaluate $1 first",
            "finish": "evaluated to a new table with revised rows, $1",
            "conflict": {
                "ExpectedUpdateBind": "I need a value for every column",
                "IncompatibleCellType": {
                    "primary": "I needed a $1, but got a $2",
                    "secondary": "I got a $2"
                }
            }
        },
        "AnyType": {
            "name": "any type",
            "emotion": "curious",
            "doc": "I represent any any possible type. Sometimes I show up because I don't know what kind of value something is, so it could be anything."
        },
        "BooleanType": {
            "name": "boolean",
            "emotion": "kind",
            "doc": [
                "I work with @Bind to declare that a name is a @Boolean value. Like this:",
                "⧼hungry•?: 'jello'⧽",
                "If you want to be sure that something is @Boolean, use me, and I'll check!"
            ]
        },
        "ConversionType": {
            "name": "conversion",
            "emotion": "serious",
            "doc": [
                "I work with @Bind to indicate that a name is a @ConversionDefinition. You probably don't need to use me, because not a lot of people pass me around as a value, but if you did, I would look like this:",
                "⧼magic•?→'': → ? '' . ? 'yep' 'nope'⧽"
            ]
        },
        "ExceptionType": {
            "name": "exception",
            "emotion": "neutral",
            "doc": "I represent an exception. There's no way to tell bind that I am one, because exceptions only ever halt @Program, so you can't use them as values."
        },
        "FunctionDefinitionType": {
            "name": "function type",
            "emotion": "happy",
            "doc": [
                "I represent a @FunctionDefinition. I'm really helpful if you want to say what kind of function a @Bind holds! Like this:",
                "⧼math•ƒ (# # # #) #?: ƒ interesting(a•# b•# c•# d•#) a + b + c + d⧽"
            ]
        },
        "FunctionType": {
            "name": "function type",
            "emotion": "curious",
            "doc": [
                "I represent a @FunctionDefinition. I'm really helpful if you want to say what kind of function a @Bind holds! Like this:",
                "⧼math•ƒ (# # # #) #?: ƒ interesting(a•# b•# c•# d•#) a + b + c + d⧽"
            ]
        },
        "ListType": {
            "name": "list type",
            "description": "$1[list of $1|list]",
            "emotion": "cheerful",
            "doc": [
                "I am /such/ a fan of @List. I get to tell @Bind what kind of list they are! Like this, I'm saying that it's a list of @Number:",
                "⧼things•[#]: [ 1 2 3 4 5 ]⧽"
            ]
        },
        "MapType": {
            "name": "map type",
            "description": "map from $1[$1|any] to $2[$2|any]",
            "emotion": "kind",
            "doc": [
                "Do you know how awesome @Map is? Like really awesome. I tell @Bind what kind of map they are all the time, like this map of numbers to lists:",
                "⧼stuff•{'':[]}: {}⧽"
            ]
        },
        "NumberType": {
            "name": "number type",
            "description": "$1[$1 | number]",
            "emotion": "precise",
            "doc": [
                "You know what @Bind should be? A @Number. Because numbers are the best.",
                "⧼count•#: 17⧽"
            ]
        },
        "NameType": {
            "name": "name type",
            "description": "$1 type",
            "emotion": "curious",
            "doc": [
                "I represent a @StructureDefinition by it's name. So like, if you had a structure like this, you could make a @Bind that stores the values it creates.",
                "⧼•Friend(name•'')\nbestie•Friend: Friend('Jonah')⧽"
            ],
            "conflict": {
                "UnknownTypeName": "type names can only refer to structures or type variables, but this refers to a $1"
            }
        },
        "NeverType": {
            "name": "never type",
            "emotion": "curious",
            "doc": "I represent a type that is impossible. Like when you ask @Is if something is a @Number, but it can never be a number."
        },
        "NoneType": {
            "name": "none type",
            "emotion": "neutral",
            "doc": [
                "@None is the best nothing there is, and I am their faithful representative.",
                "⧼space•ø: ø⧽"
            ]
        },
        "SetType": {
            "name": "set type",
            "description": "$1[$1 set|set] type",
            "emotion": "kind",
            "doc": [
                "@Set is the BEST, like seriously. I'm telling @Bind all the time, make things a set of something!",
                "⧼unique•{''}: {'something' 'anything' 'someone'}⧽"
            ]
        },
        "StreamDefinitionType": {
            "name": "stream definition type",
            "emotion": "angry",
            "doc": "I represent a stream you have defined, which isn't possible, so why are you even reading this?"
        },
        "StreamType": {
            "name": "stream type",
            "emotion": "curious",
            "doc": [
                "I celebrate the beauty and meaning of streams… by telling @Bind to store them:",
                "⧼time•…#ms: Time()⧽"
            ]
        },
        "StructureDefinitionType": {
            "name": "structure definition type",
            "description": "$1",
            "emotion": "kind",
            "doc": "I am an internal type to represent the type of default value types."
        },
        "UnknownType": {
            "name": "unknown type",
            "unknown": "unknown",
            "connector": ", because",
            "emotion": "curious",
            "doc": "Umm... I don't know what I represent, but I really am curious. Do you know? It seems like we should know. You might need to tell us if we can't figure it out."
        },
        "TableType": {
            "name": "table type",
            "emotion": "angry",
            "doc": "I represent a Table.",
            "conflict": {
                "ExpectedColumnType": "I need a column type"
            }
        },
        "TextType": {
            "name": "text type",
            "description": "$1[$1|text]",
            "emotion": "happy",
            "doc": [
                "I fabulously represent the most fabulous kind of value there is, @Text.",
                "⧼story•'': 'Once upon a time...'⧽"
            ]
        },
        "TypePlaceholder": {
            "name": "placeholder type",
            "emotion": "eager",
            "doc": "I hope to represent a type some day, kind of like my bestie @ExpressionPlaceholder represents an expression! Will you help me decide what kind?"
        },
        "UnionType": {
            "name": "option type",
            "description": "$1 | $2",
            "emotion": "curious",
            "doc": [
                "Who should I represent, A or B or something else? I can never decide!",
                "⧼indecision•''|#|{ø}: \"I don't know!\"⧽"
            ]
        },
        "Unit": {
            "name": "unit",
            "description": "$1",
            "emotion": "precise",
            "doc": [
                "I represent any unit a @Number might have, including no unit, to the most complicated unit you can imagine. Like gravity, for example:",
                "⧼gravity•m/s^2: 9.8m/s^2⧽",
                "I show up in @Bind, but also right after @Number. I help make sure that numbers are of the same kinds, and will definitely tell you if they aren't, in case its a mistake!"
            ]
        },
        "UnparsableType": {
            "name": "unparsable type",
            "emotion": "curious",
            "doc": "I represent the type of an unknown expression. I show up when you try to use that expression for something."
        },
        "VariableType": {
            "name": "variable type",
            "emotion": "curious",
            "doc": "Do you know @TypeVariable, and how they represent some unknown kind of value? I represent them in all negotiations between values."
        },
        "CycleType": {
            "name": "cycle type",
            "description": "depends on itself",
            "emotion": "curious",
            "doc": "Sometimes values depend on themselves, and so we don't know what kind of value they are. I represent that situation."
        },
        "UnknownVariableType": {
            "name": "unknown variable type",
            "emotion": "curious",
            "doc": "Sometimes we try to guess what kind of value something is; I show up when we don't know."
        },
        "NotAType": {
            "name": "unexpected type",
            "description": "not a $1",
            "emotion": "curious",
            "doc": "Sometimes we know what kind of value something should be. Like @ListAccess needs a @Number. If we don't get it, I represent that something is a type other than what we expected."
        },
        "NoExpressionType": {
            "name": "no expression type",
            "emotion": "angry",
            "doc": "You know how @Block needs at least one expression? I'm what you get when you don't give one. So give one!"
        },
        "NotEnclosedType": {
            "name": "not in structure, conversion, or reaction",
            "emotion": "curious",
            "doc": "@This, as neat as they are, only belongs in particular places. I show up when they get lost, and so no one knows what value they represent."
        },
        "NotImplementedType": {
            "name": "unimplemented",
            "emotion": "curious",
            "doc": "When you use @ExpressionPlaceholder, but don't say what type they are, I'm the type you get. Deal with it!"
        },
        "UnknownNameType": {
            "name": "unknown name",
            "description": "$1[$1 isn't defined | a name wasn't given]",
            "emotion": "curious",
            "doc": "You know how sometimes @Reference and @PropertyReference don't know the name you're talking about? I'm around when that happens, to represent that we don't know who you're talking about."
        }
    },
    "native": {
        "Boolean": {
            "doc": [
                "We are ⧼⊤⧽ and ⧼⊥⧽. ⧼⊤⧽ is true. ⧼⊥⧽ is false. ⧼⊤⧽ is not ⧼⊥⧽; ⧼⊥⧽ is not ⧼⊤⧽. This is how it is.",
                "How do you make us? Just ⧼⊤⧽ and ⧼⊥⧽, nothing more, nothing less.",
                "Some use the keyboard (/ctrl+9/ for ⧼⊤⧽ and /ctrl+0/ for ⧼⊥⧽). Some use the character search at the bottom of the editor. Or you can drag us from here.",
                "Check out our @FunctionDefinition below. They're very logical."
            ],
            "name": ["⊤⊥", "Boolean"],
            "function": {
                "and": {
                    "doc": [
                        "Evaluates to ⧼⊤⧽ *only* when both values are ⧼⊤⧽. Helpful for determining if many things are all true. There are only four possible outcomes",
                        "⧼⊤ & ⊤⧽",
                        "⧼⊤ & ⊥⧽",
                        "⧼⊥ & ⊤⧽",
                        "⧼⊥ & ⊥⧽"
                    ],
                    "names": ["&", "and"],
                    "inputs": [
                        {
                            "doc": "The other @Boolean to check. If the first is ⧼⊥⧽, it doesn't matter what this is, the function will evaluate to ⧼⊥⧽.",
                            "names": "value"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "Evaluates to ⧼⊤⧽ when *either* value are ⧼⊤⧽. Helpful for determining if one of many things are true. There are only four possible outcomes",
                        "⧼⊤ | ⊤⧽",
                        "⧼⊤ | ⊥⧽",
                        "⧼⊥ | ⊤⧽",
                        "⧼⊥ | ⊥⧽"
                    ],
                    "names": ["|", "or"],
                    "inputs": [
                        {
                            "doc": "The other @Boolean to check. If the first is ⧼⊥⧽, the function will only evaluate to ⧼⊤⧽ if this is ⧼⊤⧽.",
                            "names": "value"
                        }
                    ]
                },
                "not": {
                    "doc": "Gets the opposite of itself: if ⧼⊤⧽, it gives ⧼⊥⧽, if ⧼⊥⧽, it gives ⧼⊤⧽.",
                    "names": ["~", "not"],
                    "inputs": []
                },
                "equals": {
                    "doc": "True if both are ⧼⊤⧽ or both are ⧼⊥⧽.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The other value to check.", "names": "value" }
                    ]
                },
                "notequal": {
                    "doc": "True if both are opposites.",
                    "names": ["≠", "notequal"],
                    "inputs": [
                        { "doc": "The other value to check.", "names": "value" }
                    ]
                }
            },
            "conversion": {
                "text": "Converts a @Boolean to the equivalent @Text values, ⧼'⊤'⧽ and ⧼'⊥'⧽"
            }
        },
        "None": {
            "doc": [
                "/Hi, @FunctionDefinition here. @None doesn't like to say much, so I'll interpret./",
                "I am @None. Invoke me with ⧼ø⧽. I am helpful when you want to represent the absense of something."
            ],
            "name": ["ø", "None"],
            "function": {
                "equals": {
                    "doc": "Is another value also nothing? It better be, otherwise, ⧼⊥⧽.",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "The other value.", "names": "value" }]
                },
                "notequals": {
                    "doc": "Is another value /not/ nothing?",
                    "names": ["≠", "notequal"],
                    "inputs": [{ "doc": "The other value.", "names": "value" }]
                }
            },
            "conversion": {
                "text": "Want to make ⧼ø⧽ into ⧼'ø'⧽? This is your chance."
            }
        },
        "Text": {
            "doc": [
                "I can be any text you like, from any language, and using any of these symbols opening and closing symbols: ⧼\"\"⧽, ⧼“”⧽, ⧼„“⧽, ⧼''⧽, ⧼‘’⧽, ⧼‹›⧽, ⧼«»⧽, ⧼「」⧽, or ⧼『』⧽.",
                "To illustrate, consider these beautiful phrases",
                "⧼“There are only two ways to live your life. One is as though nothing is a miracle. The other is as though everything is a miracle.”⧽",
                "⧼『一日三秋』⧽",
                "Just remember to close me if you open me, and use the matching symbol. Otherwise I won't know that you're done with your words.",
                "Otherwise, there just so many glorious functions that @FunctionDefinition made for me to do all kinds of things with words!"
            ],
            "name": ["''", "Text"],
            "function": {
                "length": {
                    "doc": [
                        "Evaluates to number of legible characters in the text; one letter is one character, one emoji is one character, etc. For example:",
                        "⧼'hello'.length()⧽",
                        "⧼'🐈📚'.length()⧽"
                    ],
                    "names": ["📏", "length"],
                    "inputs": []
                },
                "equals": {
                    "doc": "⧼⊤⧽ if I am the same character sequence as the given @Text.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The @Text to compare.", "names": "value" }
                    ]
                },
                "notequals": {
                    "doc": "⧼⊤⧽ if I am /not/ the same character sequence as the given @Text.",
                    "names": "≠",
                    "inputs": [
                        { "doc": "The @Text to compare", "names": "value" }
                    ]
                },
                "repeat": {
                    "doc": [
                        "I make a new @Text that's me, repeated the number of times of ⧼count⧽:",
                        "⧼'hi ' · 5⧽",
                        "If you give me a fractional @Number, I ignore the fraction:",
                        "⧼'hi ' · 5.5⧽",
                        "If you give me a negative @Number or zero, I give an empty @Text.",
                        "⧼'hi ' · -5⧽"
                    ],
                    "names": ["·", "🔁", "repeat"],
                    "inputs": [
                        {
                            "doc": "The number of times to repeat myself in the new text.",
                            "names": "count"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "I divide myself into a @List of @Text, using the given @Text as a separator, and removing the separators. For example:",
                        "⧼'apples, oranges, grapes' ÷ ', '⧽",
                        "If the separator is an empty @Text, I divide myself into characters:",
                        "⧼'🖌️🏠🥸' ÷ ''⧽"
                    ],
                    "names": ["÷", "segment"],
                    "inputs": [
                        {
                            "doc": "The @Text to use as a separator.",
                            "names": "delimiter"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Sometimes it's helpful to combine to @Text into one. Give me another @Text and I'll make a new text that joins us together:",
                        "⧼'hello ' + 'verse'⧽"
                    ],
                    "names": ["+", "combine"],
                    "inputs": [
                        { "doc": "The @Text to append.", "names": "text" }
                    ]
                },
                "has": {
                    "doc": [
                        "⧼⊤⧽ if the given @Text appears in me.",
                        "⧼'did you find what you were looking for?'.has('you')⧽"
                    ],
                    "names": ["⊆", "has"],
                    "inputs": [
                        {
                            "doc": "The @Text to search for in me.",
                            "names": "text"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "Splits the text into a list of individual characters.",
                "number": "Converts text into a @Number, and if it's not a number, a not a number value."
            }
        },
        "Number": {
            "doc": [
                "I create @Number, with any number of units you can imagine!",
                "Here are my top 5:",
                "⧼0⧽",
                "⧼1story⧽",
                "⧼πpie⧽",
                "⧼∞rock⧽",
                "⧼1000000hugs⧽",
                "That's basically an infinite number of numbers.",
                "And an infinite number of units!",
                "And an infinite number of number/unit pairs…",
                "I can be integers, real numbers, negative, positive, fractional, decimal, even not a number.",
                "And you can write me with many different number systems, including Arabic ⧼123⧽, Roman ⧼ⅩⅩⅩⅠⅩ⧽, Japanese ⧼二十⧽, and more:",
                "⧼1 + Ⅰ + 一⧽",
                "You can also write me in bases 2 to 16 by putting a base number like this:",
                "⧼2;11111111⧽",
                "⧼10;255⧽",
                "⧼16;FF⧽",
                "There is one special number called NaN that is possible when you write something that isn't a number:",
                "⧼2;22⧽",
                "There is no digit '2' in base 2, so it's not a valid number. NaN will also show up if you try to convert non-number text to number",
                "⧼'hi'→#⧽"
            ],
            "name": ["#", "Number"],
            "function": {
                "add": {
                    "doc": [
                        "I add a @Number with the same @Unit to myself, creating a new @Number of the same @Unit.",
                        "For example:",
                        "⧼1 + 1⧽",
                        "⧼3cat + 5cat⧽",
                        "If the units don't match, I halt the show.",
                        "⧼3cat + 5dog⧽"
                    ],
                    "names": ["+", "add"],
                    "inputs": [
                        { "doc": "The @Number to add.", "names": "number" }
                    ]
                },
                "subtract": {
                    "doc": [
                        "I subtract the @Number you give me from myself, creating a new @Number of the same @Unit.",
                        "For example:",
                        "⧼1 - 1⧽",
                        "⧼3cat - 5cat⧽",
                        "If the units don't match, I halt the show.",
                        "⧼3cat - 5dog⧽"
                    ],
                    "names": ["-", "subtract"],
                    "inputs": [
                        {
                            "doc": "The @Number to subtract from me.",
                            "names": "number"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "I multiply myself to the given @Number, creating a product of my @Unit and the given number's @Unit:",
                        "⧼5 · 5⧽",
                        "⧼5m · 5m⧽",
                        "⧼5m · 1/s⧽"
                    ],
                    "names": ["·", "multiply"],
                    "inputs": [
                        { "doc": "The number to multiply.", "names": "number" }
                    ]
                },
                "divide": {
                    "doc": [
                        "I divide myself by the given @Number, creating a quotient of my @Unit and the given number's @Unit:",
                        "⧼5 ÷ 5⧽",
                        "⧼5m ÷ 5m⧽",
                        "⧼5m ÷ 5s⧽"
                    ],
                    "names": ["÷", "divide"],
                    "inputs": [
                        {
                            "doc": "The @Number to divide me by.",
                            "names": "number"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "I divide myself by the given @Number, but give the remainder:",
                        "⧼10 % 2⧽",
                        "⧼10m % 2⧽",
                        "⧼10m/s % 3⧽"
                    ],
                    "names": ["%", "remainder"],
                    "inputs": [
                        {
                            "doc": "The @Number to divide me by.",
                            "names": "number"
                        }
                    ]
                },
                "integer": {
                    "doc": [
                        "I create a new @Number that removes my fractional part, turning me into an integer.",
                        "⧼10.522391.integer()⧽"
                    ],
                    "names": ["integer"],
                    "inputs": []
                },
                "positive": {
                    "doc": [
                        "I create a new @Number that makes me positive, if negative.",
                        "⧼-200.positive()⧽"
                    ],
                    "names": ["positive"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "I create a new @Number that rounds me to the closest integer.",
                        "⧼9.4.round()⧽",
                        "⧼9.5.round()⧽",
                        "⧼9.6.round()⧽"
                    ],
                    "names": ["round"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "I raise myself to the given @Number's power. Fractional exponents are okay!",
                        "⧼2 ^ 8⧽",
                        "⧼10 ^ -2⧽",
                        "⧼5 ^ -.5⧽"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "The exponent to raise me to.",
                            "names": "number"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "I create the root of myself using the given root.",
                        "⧼4 √ 2⧽",
                        "⧼1000 √ 3⧽"
                    ],
                    "names": ["√", "root"],
                    "inputs": [
                        { "doc": "The root to compute.", "names": "number" }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "⧼⊤⧽ if I'm less than the given @Number:",
                        "⧼1 < 2⧽",
                        "⧼2 < 1⧽"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "⧼⊤⧽ if I'm less than or equal to the given @Number:",
                        "⧼1 ≤ 2⧽",
                        "⧼2 ≤ 1⧽",
                        "⧼2 ≤ 2⧽"
                    ],
                    "names": ["≤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "⧼⊤⧽ if I'm greater than to the given @Number:",
                        "⧼1 > 2⧽",
                        "⧼2 > 1⧽"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "⧼⊤⧽ if I'm greater than or equal to the given @Number:",
                        "⧼1 ≥ 2⧽",
                        "⧼2 ≥ 1⧽",
                        "⧼2 ≥ 2⧽"
                    ],
                    "names": ["≥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "⧼⊤⧽ if I'm equal to the given @Number:",
                        "⧼1 = 2⧽",
                        "⧼2 = 2⧽"
                    ],
                    "names": ["=", "equal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "⧼⊤⧽ if I'm equal to the given @Number:",
                        "⧼1 ≠ 2⧽",
                        "⧼2 ≠ 2⧽"
                    ],
                    "names": ["≠", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "cos": {
                    "doc": ["Compute the cosine of me.", "⧼π.cos()⧽"],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["Compute the sine of me.", "⧼π.cos()⧽"],
                    "names": ["sin", "sine"],
                    "inputs": []
                }
            },
            "conversion": {
                "text": "An Arabic @Text representation of my digits.",
                "list": "A list of the numbers 1 to whatever number is given, such as\n⧼10→[]⧽.",
                "s2m": "Seconds to minutes",
                "s2h": "Seconds to hours",
                "s2day": "Seconds to days",
                "s2wk": "Seconds to weeks",
                "s2year": "Seconds to years",
                "s2ms": "Seconds to miliseconds",
                "ms2s": "Milliseconds to seconds",
                "min2s": "Minutes to seconds",
                "h2s": "Hours to seconds",
                "day2s": "Days to seconds",
                "wk2s": "Weeks to seconds",
                "yr2s": "Years to seconds",
                "m2pm": "Meters to picometers",
                "m2nm": "Meters to nanometers",
                "m2micro": "Meters to micrometers",
                "m2mm": "Meters to millimeters",
                "m2cm": "Meters to centimenters",
                "m2dm": "Meters to decimeters",
                "m2km": "Meters to kilometers",
                "m2Mm": "Meters to megameters",
                "m2Gm": "Meters to gigameters",
                "m2Tm": "Meters to terameters",
                "pm2m": "Picometers to meters",
                "nm2m": "Nanometers to meters",
                "micro2m": "Micrometers to meters",
                "mm2m": "Millimeters to meters",
                "cm2m": "Centimeters to meters",
                "dm2m": "Decimeters to meters",
                "km2m": "Kilometers to meters",
                "Mm2m": "Megameters to meters",
                "Gm2m": "Gigameters to meters",
                "Tm2m": "Terameters to meters",
                "km2mi": "Kilometers to miles",
                "mi2km": "Miles to kilometers",
                "cm2in": "Centimeters to inches",
                "in2cm": "Inches to centimeters",
                "m2ft": "Meters to feet",
                "ft2m": "Feet to meters",
                "g2mg": "Grams to milligrams",
                "mg2g": "Milligrams to grams",
                "g2kg": "Grams to kilograms",
                "kg2g": "Kilograms to grams",
                "g2oz": "Grams to ounces",
                "oz2g": "Ounces to grams",
                "oz2lb": "Ounces to pounds",
                "lb2oz": "Pounds to ounces"
            }
        },
        "List": {
            "doc": [
                "I'm a sequence of values, of any kind!",
                "You can put anything in me: @Boolean, @Number, @Text, @None, even other @List, @Set, @Map, or any expression. Here's a simple one:",
                "⧼['apple' 'banana' 'mango']⧽",
                "What makes me special is that I keep things in order and I number everything from 1 to however many items are in me.",
                "My items are numbered, starting from 1. You can get values that I'm storing with @ListAccess, using their number:",
                "For example, the second value in this list is ⧼['banana']⧽",
                "⧼['apple' 'banana' 'mango'][2]⧽",
                "I can have anything in me. Look at this list, with @Text, @Number, and @Time!",
                "⧼['apple' 10 + 10 Time()]⧽",
                "I can do call kinds of exiting things with my @FunctionDefinition!"
            ],
            "name": ["[]", "List"],
            "kind": "Kind",
            "out": "Result",
            "outofbounds": "outofbounds",
            "function": {
                "add": {
                    "doc": [
                        "I create a new @List with the given item.",
                        "⧼['apple' 'banana' 'mango'].add('watermelon')⧽"
                    ],
                    "names": ["add"],
                    "inputs": [
                        {
                            "doc": "I the value you want to add.",
                            "names": "item"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "I create a new @List with my values, then all the values of the given @List.",
                        "⧼['apple' 'banana' 'mango'].append(['watermelon' 'starfruit'])⧽"
                    ],
                    "names": ["append"],
                    "inputs": [
                        { "doc": "The list of values to add.", "names": "list" }
                    ]
                },
                "replace": {
                    "doc": [
                        "I create a new list that replaces the value at the given index with the given value.",
                        "⧼['apple' 'banana' 'mango'].replace(1 'kiwi')⧽"
                    ],
                    "names": ["replace"],
                    "inputs": [
                        {
                            "doc": "The index of the value to replace",
                            "names": "index"
                        },
                        { "doc": "The replacement value", "names": "value" }
                    ]
                },
                "length": {
                    "doc": "The @Number of items in me.",
                    "names": ["📏", "length"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "A randonly selected one of my items, or @None if I'm empty.",
                        "⧼['apple' 'banana' 'mango'].random()⧽"
                    ],
                    "names": "random",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "The first item in me, or @None if I'm empty.",
                        "⧼['apple' 'banana' 'mango'].first()⧽"
                    ],
                    "names": "first",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "The last item in me, or @None if I'm empty.",
                        "⧼['apple' 'banana' 'mango'].first()⧽"
                    ],
                    "names": "last",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "⧼⊤⧽ if I have an item equal to the given item in me.",
                        "⧼['apple' 'banana' 'mango'].has('banana')⧽"
                    ],
                    "names": "has",
                    "inputs": [
                        { "doc": "The value to search for.", "names": "item" }
                    ]
                },
                "join": {
                    "doc": [
                        "I combine the items in my list into @Text, separated by the given separator @Text.",
                        "⧼['apple' 'banana' 'mango'].join(', ')⧽"
                    ],
                    "names": "join",
                    "inputs": [
                        {
                            "doc": "The text to separate the items by, optionally empty.",
                            "names": "separator"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "I create a list without my first item.",
                        "⧼['apple' 'banana' 'mango'].sansFirst()⧽"
                    ],
                    "names": "sansFirst",
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "I create a list without my last item.",
                        "⧼['apple' 'banana' 'mango'].sansLast()⧽"
                    ],
                    "names": "sansLast",
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "Me, but without the first occurences of the given value.",
                        "⧼['apple' 'banana' 'mango' 'apple'].sans('apple')⧽"
                    ],
                    "names": "sans",
                    "inputs": [
                        {
                            "doc": "The value to remove the first occurence of.",
                            "names": "value"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "Me, but without all occurences of the given value.",
                        "⧼['apple' 'banana' 'mango' 'apple'].sans('apple')⧽"
                    ],
                    "names": "sansAll",
                    "inputs": [
                        {
                            "doc": "The value to remove all occurences of from the list.",
                            "names": "value"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "Me, but in reverse!",
                        "⧼['apple' 'banana' 'mango'].reverse()⧽"
                    ],
                    "names": "reverse",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "⧼⊤⧽ if my items and order are the exact same as the given @List.",
                        "⧼['apple' 'banana' 'mango'] = ['apple' 'mango' 'banana']⧽"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The @List to compare me to.",
                            "names": "list"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "⧼⊤⧽ if my items and order are /not/ the exact same as the given @List.",
                        "⧼['apple' 'banana' 'mango'] ≠ ['apple' 'mango' 'banana']⧽"
                    ],
                    "names": ["≠", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @List to compare me to.",
                            "names": "list"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value and optional index as input and produces a value, and I'll evaluate it on each of my items, translating my values into new values.",
                        "For example, imagine I was a list of @Number and you wanted to double all of them:",
                        "⧼[2 4 6 8].translate(ƒ(num•#) num · 2)⧽"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that will translate each item.",
                            "names": "translator"
                        }
                    ],
                    "value": {
                        "doc": "The item being translated.",
                        "names": "item"
                    },
                    "index": {
                        "doc": "The index of the item being translated.",
                        "names": "index"
                    }
                },
                "filter": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value and optional index as input and produces a @Boolean, and I'll create a new list that only includes the items that result ⧼⊤⧽.",
                        "For example, imagine I was a list of @Number and you only wanted the positive ones:",
                        "⧼[2 -4 8 -16].filter(ƒ(num•#) num ≥ 0)⧽"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "A @FunctionDefinition that checks each item, producing ⧼⊤⧽ if it should be kept.",
                            "names": "checker"
                        }
                    ],
                    "value": {
                        "doc": "The item being checked.",
                        "names": "item"
                    }
                },
                "all": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some condition. I'll create ⧼⊤⧽ if all the items match the condition.",
                        "For example, imagine I was a list of @Number and you wanted to know if everything was positive:",
                        "⧼[2 -4 8 -16].all(ƒ(num•#) num ≥ 0)⧽"
                    ],
                    "names": "all",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces ⧼⊤⧽ if an item satisfies your condition.",
                            "names": "checker"
                        }
                    ],
                    "value": {
                        "doc": "The item being checked.",
                        "names": "item"
                    }
                },
                "until": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some condition. I'll create a new @List that contains all the items until the condition isn't met.",
                        "For example, imagine I was a list of @Text animals and you wanted everything up until ⧼'rat'⧽ was found:",
                        "⧼['cat' 'dog' 'rat' 'mouse' 'pony'].until(ƒ(animal•'') animal = 'rat')⧽"
                    ],
                    "names": "until",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces ⧼⊤⧽ if I should stop including items.",
                            "names": "checker"
                        }
                    ],
                    "value": {
                        "doc": "The item being checked.",
                        "names": "item"
                    }
                },
                "find": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some criteria, and I'll evaluate to the matching item.",
                        "For example, imagine you wanted to find the first animal that had the vowel ⧼'e'⧽:",
                        "⧼['cat' 'dog' 'rat' 'mouse' 'pony'].find(ƒ(animal•'') animal.has('e'))⧽"
                    ],
                    "names": "find",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces ⧼⊤⧽ if it matches your search criteria.",
                            "names": "checker"
                        }
                    ],
                    "value": {
                        "doc": "The item being checked.",
                        "names": "item"
                    }
                },
                "combine": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes the most recent combination and a next value, and creates a next combination, and I'll move from the first to last of my items, creating successive combinations, and evaluating to the final combination your @FunctionDefinition evaluates to.",
                        "This is really helpful for combining all of the items in me into a single value. For example, imagine you wanted to add a list of numbers:",
                        "⧼[3 9 2 8 1 4].combine(0 ƒ(sum•# number•#) sum + number)⧽"
                    ],
                    "names": "combine",
                    "inputs": [
                        {
                            "doc": "The starting combination.",
                            "names": "initial"
                        },
                        {
                            "doc": "The @FunctionDefinition that takes the latest combination and the next value and produces the next combination.",
                            "names": "combiner"
                        }
                    ],
                    "combination": {
                        "doc": "The current combination",
                        "names": "combination"
                    },
                    "next": {
                        "doc": "The next item to combine.",
                        "names": "next"
                    },
                    "index": {
                        "doc": "The index of the next item",
                        "names": "index"
                    }
                }
            },
            "conversion": {
                "text": "To a @Text representation of the list.",
                "set": "To a @Set, helpful for removing duplicates."
            }
        },
        "Set": {
            "doc": [
                "I'm a set of values! That means I can contain any number of values, including no values. You can make me like this:",
                "⧼{1 2 3}⧽",
                "I'm really good if you want to keep a collection of things without any duplicates.",
                "That means that if you give me values I already have, I'll ignore the extras.",
                "For example, this set has many duplicates:",
                "⧼{1 1 2 2 3 3}⧽",
                "I evaluate it to just ⧼{1 2 3}⧽.",
                "If you want to see if I have a value in me, @SetOrMapAccess can help:",
                "⧼{'jar' 'bottle' 'glass'}{'cup'}⧽"
            ],
            "name": ["{}", "Set"],
            "kind": "Kind",
            "function": {
                "equals": {
                    "doc": [
                        "I'm ⧼⊤⧽ if the given @Set and I have the exact same values:",
                        "⧼{1 2 3} = {2 3 4}⧽"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The @Set to compare.", "names": "set" }
                    ]
                },
                "notequals": {
                    "doc": [
                        "I'm ⧼⊤⧽ if the given @Set and I don't have the exact same values:",
                        "⧼{1 2 3} ≠ {2 3 4}⧽"
                    ],
                    "names": ["≠", "notequal"],
                    "inputs": [
                        { "doc": "The @Set to compare.", "names": "set" }
                    ]
                },
                "add": {
                    "doc": [
                        "Give me an item to add and I'll make a new @Set with my items and the given item.",
                        "⧼{1 2 3} + 4⧽"
                    ],
                    "names": ["add", "+"],
                    "inputs": [{ "doc": "The item to add", "names": "item" }]
                },
                "remove": {
                    "doc": [
                        "Give me an item to remove and I'll make a new @Set without the item.",
                        "⧼{1 2 3} - 2⧽",
                        "If I don't have the item, I'll just evaluate to myself."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        { "doc": "The item to remove.", "names": "item" }
                    ]
                },
                "union": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has my items and the set's items.",
                        "⧼{1 2 3} ∪ {3 4 5}⧽"
                    ],
                    "names": ["union", "∪"],
                    "inputs": [
                        {
                            "doc": "The @Set to combine with me.",
                            "names": "set"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has only the items we have in common.",
                        "⧼{1 2 3} ∩ {3 4 5}⧽"
                    ],
                    "names": ["intersection", "∩"],
                    "inputs": [
                        { "doc": "The set to compare with me.", "names": "set" }
                    ]
                },
                "difference": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has the items has only the items we have in common.",
                        "⧼{1 2 3}.difference({3 4 5})⧽"
                    ],
                    "names": "difference",
                    "inputs": [
                        {
                            "doc": "The set whose items should be removed from me.",
                            "names": "set"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me @FunctionDefinition that takes an item and produces ⧼⊤⧽ if it should be kept, and I'll make a @Set that only contains the items that meet your criteria.",
                        "For example, let's find the odd numbers in me:",
                        "⧼{1 2 3 4 5 6 7 8 9}.filter(ƒ(num•#) (num % 2) = 1)⧽"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that checks an item to see if it should be kept.",
                            "names": "checker"
                        }
                    ],
                    "value": {
                        "doc": "The item being checked.",
                        "names": "value"
                    }
                },
                "translate": {
                    "doc": [
                        "Give me @FunctionDefinition that takes an item and produces a new item based on it, then I'll translate all the items in me into a new @Set (removing any duplicates).",
                        "For example, let's make all my @Number into @Text:",
                        "⧼{1 2 3 4 5 6 7 8 9}.translate(ƒ(num•#) num→'')⧽"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that translates one of my items into the new item you want.",
                            "names": "set"
                        }
                    ],
                    "value": {
                        "doc": "The item being translated.",
                        "names": "value"
                    }
                }
            },
            "conversion": {
                "text": "A @Text representation of a @Set",
                "list": "A @List representation of the items in the set."
            }
        },
        "Map": {
            "doc": [
                "I bring values together, mapping *keys* to *values*. For example:",
                "⧼{'amy': 6points 'tony':3points 'shiela': 8points}⧽",
                "My keys can be any kind of value, and my values can be any kind of value.",
                "Some people like to think of my like an index, or a dictionary, where you give me something, and I give you what it's mapped to.",
                "If you wanted to check what something is mapped to, you can give @SetOrMapAccess, a key and they'll give you the value:",
                "⧼{'amy': 6points 'tony':3points 'shiela': 8points}{'amy'}⧽",
                "If there is no matching key, I'll give you @None.",
                "⧼{'amy': 6points 'tony':3points 'shiela': 8points}{'jen'}⧽",
                "You can also make an empty map like this:",
                "⧼{:}⧽",
                "I know how to many wonderful things with my pairings."
            ],
            "name": ["{:}", "Map"],
            "key": "Key",
            "value": "Value",
            "result": "Result",
            "function": {
                "equals": {
                    "doc": [
                        "⧼{⊤}⧽ if my pairings are the exact same as the given @Map's.",
                        "⧼{1:1 2:2} = {1:1 2:3}⧽"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The @Map to compare me to.",
                            "names": "value"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "⧼{⊤}⧽ if my pairings are /not/ the exact same as the given @Map's.",
                        "⧼{1:1 2:2} ≠ {1:1 2:3}⧽"
                    ],
                    "names": ["≠", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @Map to compare me to.",
                            "names": "value"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "I'll make a new @Map with all the same pairings, but with the new pairing you give me. If I already have the key, I'll pair it to the new value.",
                        "⧼{'amy': 6points 'tony':3points}.pair('jen' 0points)⧽"
                    ],
                    "names": "pair",
                    "inputs": [
                        { "doc": "Key to pair with a value.", "names": "key" },
                        {
                            "doc": "The value to pair with the key",
                            "names": "value"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "I'll make a new @Map without the key you give me, removing its pairing.",
                        "⧼{'amy': 6points 'tony':3points}.unpair('amy')⧽"
                    ],
                    "names": "unpair",
                    "inputs": [{ "doc": "The key to forget.", "names": "key" }]
                },
                "remove": {
                    "doc": [
                        "I'll create a new @Map without any keys that have the value.",
                        "⧼{'amy': 0points 'jen': 0points 'tony':3points}.remove(0points)⧽"
                    ],
                    "names": "remove",
                    "inputs": [
                        {
                            "doc": "The value to remove from me, along with any keys its paired to.",
                            "names": "value"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a key and value and evaluates to ⧼⊤⧽ if a pairing should be kept. I'll create a new @Map that meets your criteria.",
                        "For example, here we want to keep any pairings that are Amy or have more than zero points.",
                        "⧼{'amy': 0points 'jen': 0points 'tony':3points}.filter(ƒ(key•'' value•#points) (key = 'amy') | (value > 0points))⧽"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that decides whether to keep a pairing.",
                            "names": "checker"
                        }
                    ],
                    "key": { "doc": "The key being checked.", "names": "key" },
                    "value": {
                        "doc": "The value being checked.",
                        "names": "value"
                    }
                },
                "translate": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a key and value and evaluates the value to a new value. I'll create a new @Map with the same keys but updated values.",
                        "For example, let's give everyone one point since they've been so nice.",
                        "⧼{'amy': 5points 'jen': 3points 'tony': 0points}.translate(ƒ(key•'' value•#points) value + 1points)⧽"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that translates each value.",
                            "names": "translator"
                        }
                    ],
                    "key": {
                        "doc": "The key of the value being translated.",
                        "names": "key"
                    },
                    "value": {
                        "doc": "The value being translated.",
                        "names": "value"
                    }
                }
            },
            "conversion": {
                "text": "A @Text representation of the mapping.",
                "set": "The keys of the @Map",
                "list": "A list of the values in the @Map"
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "17!",
                "/@FunctionDefinition here, I'll explain this one./",
                "So @Random is a curious stream that creates an infinite sequence of random numbers. It's curious because its the only stream that doesn't change on its own, and so @Program won't reevaluate wheni it's used.",
                "Instead, every time it's used, it evaluates to a different value, creating the wonderful chaos that comes with unpredictability.",
                "By default, it gives @Number values between ⧼0⧽ and ⧼1⧽:",
                "⧼Random()⧽",
                "But you can give it a value, and it will generate values between ⧼0⧽ and the value:",
                "⧼Random(10)⧽",
                "And if you give it two values, it will generate values between and including the two values:",
                "⧼Random(-10 10)⧽",
                "If your ranges have units, they will be preserved (and if they don't match, the minimum's unit will be used):",
                "⧼Random(-10m 10m)⧽"
            ],
            "names": ["🎲", "Random"],
            "min": {
                "names": "min",
                "doc": "The minimum value that will be created, or if it's larger than 0, the maximum value. If @None is provided, then the miniumum is ⧼0⧽."
            },
            "max": {
                "names": "max",
                "doc": "The maximum value that will created, or if its smaller than the minimum provided, the minimum. If @None is provided, than the maximum is ⧼1⧽."
            }
        },
        "Choice": {
            "doc": [
                "/clickety tap!/",
                "/@FunctionDefinition here, I'll explain this one./",
                "Think of @Choice like a stream of @Type/name that are selected by your audience. If someone clicks, taps, or keyboard selects by pressing /Enter/ on a @Phrase with a name -- @Choice will have a new value matching the name.",
                "So the best way to use it is to create a performance with named selectable phrases @Phrase, and then use a @Reaction to decide what to do when that name is chosen.",
                "Here's the simplest example:",
                "⧼Group(\nStack() \n[\nPhrase('one' selectable:⊤ name:'1') \nPhrase('two' selectable:⊤ name:'2') \nPhrase(Choice())\n]\n)⧽",
                "Copy this into the editor and then select one of the two @Phrase. You'll see the third @Phrase shows the name that was selected."
            ],
            "names": ["🔘", "Choice"]
        },
        "Button": {
            "doc": [
                "/click click click/",
                "/@FunctionDefinition here, I'll explain this one./",
                "@Button is a great way to listen to a mouse or trackpad. Of course, a mouse or trackpad isn't an ideal choice for listening to an audience, since not everyone can use one. The more accessible choice is @Choice.",
                "But if you /really/ need to listen to a mouse button, this is the way to do it. It will provide a stream of @Boolean, representing whether the primary button is up ⧼⊥⧽ or down ⧼⊤⧽.",
                "Here's a simple example:",
                "⧼Phrase(Button() → '')⧽",
                "This just makes a @Phrase that is the value of the stream as text. If you copy it into the editor and click, you'll see it toggle back and forth between ⧼⊥⧽ and ⧼⊤⧽."
            ],
            "names": ["🖱️", "Button"],
            "down": {
                "names": "down",
                "doc": "If @None, the stream will provide both up and down values. If @Boolean, it will only provide value the given @Boolean value."
            }
        },
        "Pointer": {
            "doc": [
                "/whrrrrrr/",
                "/@FunctionDefinition here, I'll explain this one./",
                "You know about mice, trackpads, and touch screens? Sometimes you want to know where an audience is pointing. That's what @Pointer provides.",
                "Of course, this is not an accessible choice: not everyone can see or easily point, so be really sure you're not excluding someone from participating by using this stream.",
                "If you're sure no one is excluded, then using @Pointer is as simple as just making a stream:",
                "⧼Pointer()⧽",
                "The @Place it provides will correspond to where on @Stage the pointer is pointing."
            ],
            "names": ["👆🏻", "Pointer"]
        },
        "Key": {
            "doc": [
                "/clickety/",
                "/@FunctionDefinition here, I'll explain this one./",
                "Keyboards have a lot of keys, don't they? @Key will tell you which one someone is pressing and releasing.",
                "Try this",
                "⧼Key()⧽",
                "See how when you type a key, it shows up on @Stage? Every time a key is pressed down, a new @Text is added to the stream, describing the key that was pressed.",
                "For a key that represents a character, the value will be the character as @Text.",
                "For special keys, like the /Escape/ key, it will be @Text that describes the key, using a <pre-defined name@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>, unfortunately available only in English.",
                "If you only want to know about a particular key, you can provide it:",
                "⧼Key('a')⧽",
                "And if you only want to know when when a @Key is released instead of pressed, you can provide a @Boolean:",
                "⧼Key('a' ⊥)⧽"
            ],
            "names": ["⌨️", "Key"],
            "key": {
                "names": "key",
                "doc": "If @None, than all keys are provided. If a specific @Text, then only that key is provided."
            },
            "down": {
                "names": "down",
                "doc": "IF @None, then key down generates inputs. If ⧼⊤⧽, then only down inputs are provided, and if ⧼⊥⧽, then only release inputs are provided."
            }
        },
        "Time": {
            "doc": [
                "/tick tick tick/",
                "@FunctionDefinition here, I'll explain @Time, since it doesn't speak.",
                "Time is a stream that ticks at a certain frequency.",
                "Each time it does, @Program reevaluates with the new time value.",
                "For example:",
                "⧼Time()⧽",
                "If you provide time a @Time/frequency, it will tick at that rate. For example:",
                "⧼Time(1000ms)⧽",
                "However, there are limits to how small it can be, since @Program needs time to evaluate before they can respond to the next tick.",
                "The smallest is probably around ⧼20ms⧽."
            ],
            "names": ["🕕", "Time"],
            "frequency": {
                "names": ["frequency"],
                "doc": "This is the frequency with which time should tick. It defaults to ⧼33ms⧽, which is about 30 times per second."
            }
        },
        "Mic": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition here, I'll take the mic.",
                "This stream is a series of amplitudes, sampled at the frequency of your choice. By default, the frequency is ⧼30hz⧽, or 30 times per second, but you can change it to anything less frequent.",
                "Mic()⧽",
                "Mic is great for listening to the sounds an audience is making, especially how loud they are!"
            ],
            "names": ["🎤", "Mic"],
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between samplings."
            }
        },
        "Camera": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition here, I can explain @Camera!",
                "So @Camera provides a @List of @Color from your world. That list essentially represents an image, but it's up to you to decide what to do with it.",
                "You could try to represent the image with a bunch of @Phrase, which could look pretty cool! Try copying this...",
                "⧼colors: Camera(32px 24px 33ms)\n\nStage(\ncolors.combine(\n[] \nƒ(phrases•[Phrase] row•[Color] y•#) \nphrases.append(\nrow.translate(\nƒ(color•Color x•#)\nPhrase('o' place: Place((x - 1) · 0.5m y · -0.5m) rest: Pose(color: color) duration: 0s\n)\n)\n)\n)\n)⧽",
                "But you could also analyze the colors to decide if a light was on or off, or if a particular color was common, letting the audience influence a performance with the colors they show."
            ],
            "names": ["🎥", "Camera"],
            "width": {
                "names": ["width"],
                "doc": "The number of @Color to sample in a row."
            },
            "height": {
                "names": ["height"],
                "doc": "The number of @Color to sample in a column."
            },
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between @Color samples."
            }
        },
        "Motion": {
            "doc": [
                "/boing boing boing/",
                "/Hi! @FunctionDefinition here. How about I explain @Motion?",
                "Basically, @Motion is a stream of @Phrase. You give it a starting @Phrase, and then it refines it with a new place and rotation based on gravity.",
                "This let's you do really simple things like creating bouncing emoji:",
                "⧼Motion(Phrase('o' place: ◆ ? Place(0m 10m) ø))⧽",
                "See how the o bounces? On the first evaluation, we give it a place up high on @Stage, but then after, it gets @None, which allows @Motion to change it to whatever position gravity would place it.",
                "Check out the many other ways to configure it below."
            ],
            "names": ["⚽️", "Motion"],
            "type": {
                "doc": "The @Phrase to refine with new @Type/rest places and rotations.",
                "names": "type"
            },
            "vx": {
                "doc": "The velocity on the x-axis at which the @Phrase should move.",
                "names": "vx"
            },
            "vy": {
                "doc": "The velocity on the y-axis at which the @Phrase should move. If it, it overrides gravity.",
                "names": "vy"
            },
            "vz": {
                "doc": "The velocity on the z-axis at which the @Phrase should move.",
                "names": "vz"
            },
            "vangle": {
                "doc": "The rotational velocity at which the @Phrase should rotate.",
                "names": "vangle"
            },
            "mass": {
                "doc": "The mass of the @Phrase, which may someday influence collisions.",
                "names": "mass"
            },
            "bounciness": {
                "doc": "The fraction between 0 and 1 that determines how much a velocity is dampened when a @Phrase collides.",
                "names": "bounciness"
            },
            "gravity": {
                "doc": "The gravity to apply to @Motion/vy.",
                "names": "gravity"
            }
        }
    },
    "output": {
        "Type": {
            "names": "Type",
            "doc": [
                "I am not a @StructureDefinition you can actually make. But I am a very important one, as I inspire the most important elements of our dance: @Phrase, @Group, and @Stage.",
                "Go meet them to learn more about how to use them."
            ],
            "size": {
                "doc": "The font size, in meters, of this output.",
                "names": "size"
            },
            "family": {
                "doc": "The name of the font family that this output should be dressed in.",
                "names": "font"
            },
            "place": {
                "doc": "The place on stage where this output should be.",
                "names": "place"
            },
            "rotation": {
                "doc": "The amount in degrees that this output should be rotated around its center.",
                "names": "rotation"
            },
            "name": {
                "doc": "The name of this output, useful for @Choice, and for enabling output with a shared name to be treated as the same output in animations.",
                "names": "name"
            },
            "selectable": {
                "doc": "If ⧼⊤⧽, indicates that the output can be selected via a pointer or keyboard.",
                "names": "selectable"
            },
            "enter": {
                "doc": "The @Pose or @Sequence to use upon entering the stage.",
                "names": "enter"
            },
            "rest": {
                "doc": "The @Pose or @Sequence to use when not entering, moving places, or exiting.",
                "names": "rest"
            },
            "move": {
                "doc": "The @Pose or @Sequence to use when moving places.",
                "names": "move"
            },
            "exit": {
                "doc": "The @Pose or @Sequence to use when exiting stage.",
                "names": "exit"
            },
            "duration": {
                "doc": "The duration to apply when moving to a different place on stage.",
                "names": ["⏳", "duration"]
            },
            "style": {
                "doc": "The animation style to use when moving to a different place on stage.",
                "names": "style"
            }
        },
        "Group": {
            "doc": [
                "Oh hello, how are you? I'm always fine when others are around, so it's great to be with you!",
                "I group together @Phrase and @Group on @Stage and put them in an @Arrangement, so there's some order to where they're placed.",
                "To work, I need you to give me an @Arrangement, and then a @List of @Type to arrange.",
                "For example, here I am with a @Stack arrangement and a few @Phrase to stack vertically:",
                "⧼Group(Stack() [Phrase('first') Phrase('second')])⧽",
                "How exactly I arrange things depend on the @Arrangement you give me."
            ],
            "names": ["🔳", "Group"],
            "layout": {
                "doc": "The arrangement to use to put @Type in their places.",
                "names": "layout"
            },
            "content": {
                "doc": "The list of @Type to arrange.",
                "names": "content"
            }
        },
        "Phrase": {
            "doc": [
                "Hello, hello! Remember me? How could anyone forget /me/. That's right, I am the manificent @Phrase, ready to represent the loveliest of @Text on @Stage.",
                "I need some @Text, obviously, but otherwise, I can do everything a @Type can do, including changing my size, font, rotation, and do all of my incredible dances with @Pose and @Sequence.",
                "You can also select me on @Stage and edit me on the palette next door."
            ],
            "names": ["💬", "Phrase"],
            "text": {
                "doc": "The characters to show on @Stage.",
                "names": "text"
            }
        },
        "Arrangement": {
            "doc": "I am an inspiration to the many other kinds of arrangment in the Verse, including @Row, @Stack, @Grid, and @Free. I work closely with @Group to ",
            "names": ["⠿", "Arrangement"]
        },
        "Row": {
            "doc": "I am @Row, a horizontal @Arrangement of @Type, with optional padding in between. Have you met my twin, @Stack?",
            "names": ["➡", "Row"],
            "description": "row of $1 phrases and groups",
            "padding": {
                "doc": "The amount of padding to place between output.",
                "names": "padding"
            }
        },
        "Stack": {
            "doc": "I am @Stack, a vertical @Arrangement of @Type, with optional padding in between. Have you met my twin, @Row? ",
            "names": ["⬇", "Stack"],
            "description": "stack of $1 phrases and groups",
            "padding": {
                "doc": "The amount of padding to place between output.",
                "names": "padding"
            }
        },
        "Grid": {
            "doc": "I am grid of @Type. Give me a row and column count and I'll make a tidy arrangement with optional padding and cell sizes.",
            "names": ["▦", "Grid"],
            "description": "$1 row $2 column grid",
            "rows": {
                "doc": "How many rows in make in the grid.",
                "names": "rows"
            },
            "columns": {
                "doc": "How many columns to make in the grid.",
                "names": "columns"
            },
            "padding": {
                "doc": "How much padding to place between cells.",
                "names": "padding"
            },
            "cellWidth": {
                "doc": "How wide the cells should be.",
                "names": "cellwidth"
            },
            "cellHeight": {
                "doc": "How tall the cells should be.",
                "names": "cellpadding"
            }
        },
        "Free": {
            "doc": "I'm like, whatever. Sit wherever you want. Just sit somewhere! Make sure all the @Type you give me have a @Place.",
            "names": ["Free"],
            "description": "free-form $1 outputs"
        },
        "Shape": {
            "doc": "I'm an inspiration to all shapes. I'm useful for telling @Stage what shape to be.",
            "names": "Shape"
        },
        "Rectangle": {
            "doc": "I am a rectangle, useful for making @Stage have a boundary the size of your choosing.",
            "names": ["Rectangle"],
            "left": {
                "doc": "The left edge of the stage on the x-axis",
                "names": "left"
            },
            "top": {
                "doc": "The top edge of the stage on the y-axes",
                "names": "top"
            },
            "right": {
                "doc": "The right edge of the stage on the x-axis",
                "names": "right"
            },
            "bottom": {
                "doc": "The bottom edge of the stage on the y-axis",
                "names": "bottom"
            }
        },
        "Pose": {
            "doc": [
                "You know when someone strikes the most amazing way of standing, a pauses, and everyone looks? That's me. I capture a pose for @Type to be in, and am the building block of their movements.",
                "So much goes into a pose. Check out my many inputs to see what kinds of poses you might make!"
            ],
            "names": ["🤪", "Pose"],
            "duration": {
                "doc": "How long this pose should take to enter from a previous pose.",
                "names": "duration"
            },
            "style": {
                "doc": "The style of animation to use when moving to this pose.",
                "names": "style"
            },
            "color": {
                "doc": "The @Color a @Type should be in this pose.",
                "names": "color"
            },
            "opacity": {
                "doc": "How transparent a @Type should be, between ⧼0⧽ and ⧼1⧽. Helpful for fading in and out.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from a @Type's place it should be. Helpful for wiggling in place.",
                "names": "offset"
            },
            "tilt": {
                "doc": "How much extra rotation a @Type should have from its original rotation.",
                "names": "tilt"
            },
            "scale": {
                "doc": "How magnified a @Type should be relative to its original size.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Whether a @Type should be mirrored on the x-axis.",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Whether a @Type should be mirrored on the y-axis.",
                "names": "flipy"
            }
        },
        "Color": {
            "doc": [
                "A am a visible color, made of three essential dimensions.",
                "Here are some common colors around the color wheel, at medium brightness and high chroma:",
                "⧼Color(50% 100 0°)⧽",
                "⧼Color(50% 100 30°)⧽",
                "⧼Color(50% 100 60°)⧽",
                "⧼Color(50% 100 90°)⧽",
                "⧼Color(50% 100 120°)⧽",
                "⧼Color(50% 100 150°)⧽",
                "⧼Color(50% 100 180°)⧽",
                "⧼Color(50% 100 210°)⧽",
                "⧼Color(50% 100 240°)⧽",
                "⧼Color(50% 100 270°)⧽",
                "⧼Color(50% 100 300°)⧽",
                "⧼Color(50% 100 330°)⧽"
            ],
            "names": ["🌈", "Color"],
            "lightness": {
                "doc": "How light I should be from ⧼0⧽ to ⧼1⧽, from black at ⧼0⧽, to grey at ⧼0.5⧽, to white at ⧼1⧽.",
                "names": ["lightness", "l"]
            },
            "chroma": {
                "doc": "How much color I should have, from ⧼0⧽ to ⧼∞⧽. No color means grey, higher numbers mean the more color.",
                "names": ["chroma", "c"]
            },
            "hue": {
                "doc": "What color I should be, on a color wheel, from megenta ⧼0⧽, red ⧼30⧽, green ⧼120⧽, to blue ⧼270⧽.",
                "names": ["hue", "h"]
            }
        },
        "Sequence": {
            "doc": [
                "Oh. My. Gosh. Director, you look amazing today! Do you want to dance with me? It's easy.",
                "You just need to give me a @Map, where each key represents what percent along we are in the dance, and each value of those keys is a @Pose to be.",
                "There are /so/ many different ways you can animate with this! For example, here's a simple one:",
                "⧼Phrase('hi' rest: Sequence({0%: Pose(tilt: 360°) 100%: Pose(tilt: 0°)})⧽",
                "This says, /at the beginning (0%), start at tilt 360, and end at tilt 0/. That'll spin us around in circles forever, since I'm set as the @Phrase's rest pose!",
                "Try your own creative dances by playing with other inputs."
            ],
            "names": ["💃", "Sequence"],
            "poses": {
                "doc": "A @Map of percentages between 0% and 100%, each paired with a @Pose. You don't have to provide all the percents; I will smoothly move a @Type between the ones you give me.",
                "names": "poses"
            },
            "count": {
                "doc": "How many times the sequence should repeat before it is done.",
                "names": "count"
            }
        },
        "Place": {
            "doc": "I'm a location on @Stage. All my inputs are optional, because I'm at the center by default.",
            "names": ["📍", "Place"],
            "x": { "doc": "A position on the x-axis.", "names": "x" },
            "y": { "doc": "A position on the y-axis", "names": "y" },
            "z": { "doc": "A position on the z-axis", "names": "z" }
        },
        "Stage": {
            "doc": [
                "HI. STAGE HERE. TELL ME WHAT TO SHOW AND I WILL SHOW IT.",
                "⧼Stage([Phrase('stufffffff')])⧽",
                "IF YOU WANT, GIVE ME A BACKGROUND @Color AND I WILL LIGHT THE STAGE ACCORDINGLY.",
                "⧼Stage([Phrase('stufffffff')] Color(0% 0 0°))⧽",
                "YOU MAY ALSO GIVE ME A FRAME BORDER.",
                "⧼Stage([Phrase('stufffffff')] Color(0% 0 0°) Rectangle(-2m -2m 2m 2m))⧽"
            ],
            "names": ["🎭", "Stage"],
            "description": "stage of $1 phrases and groups",
            "content": {
                "doc": "The list of @Type to show on stage.",
                "names": "content"
            },
            "background": {
                "doc": "The color of the background of the stage.",
                "names": "background"
            },
            "frame": {
                "doc": "The shape and size of frame to place around the stage, hiding everything outside it.",
                "names": "frame"
            }
        },
        "Easing": {
            "straight": "straight",
            "cautious": "cautious",
            "pokey": "pokey",
            "zippy": "zippy"
        },
        "sequence": {
            "sway": {
                "doc": "I create a @Sequence that sways back and forth around a @Type's center.",
                "names": ["sway"],
                "angle": {
                    "doc": "How much to tilt in the sway.",
                    "names": ["angle"]
                }
            },
            "bounce": {
                "doc": "I create a @Sequence that bounces @Type a given height.",
                "names": ["bounce"],
                "height": { "doc": "How high to bounce.", "names": ["height"] }
            },
            "spin": {
                "doc": "I create a @Sequence that rotates @Type around its center.",
                "names": ["spin"]
            },
            "fadein": {
                "doc": "I create a @Sequence that fades @Type in from invisible to visible.",
                "names": ["fadein"]
            },
            "popup": {
                "doc": "I create a @Sequence that makes @Type scale in quickly than shrink to its normal size.",
                "names": ["popup"]
            },
            "shake": {
                "doc": "I create a @Sequence that makes it look like a @Type is scared.",
                "names": ["shake"]
            }
        }
    },
    "ui": {
        "phrases": {
            "welcome": "hello",
            "motto": "Where words come to life"
        },
        "placeholders": {
            "code": "code",
            "expression": "value",
            "type": "type",
            "percent": "percent",
            "name": "name",
            "project": "untitled",
            "email": "email"
        },
        "tooltip": {
            "yes": "confirm",
            "no": "cancel",
            "play": "evaluate the program fully",
            "pause": "evaluate the program one step at a time",
            "back": "back one step",
            "backInput": "back one input",
            "out": "step out of this function",
            "forward": "forward one step",
            "forwardInput": "forward one input",
            "present": "to the present",
            "start": "to the beginning",
            "reset": "restart the evaluation of the performance from the beginning.",
            "home": "return home",
            "revert": "revert to default",
            "set": "edit this property",
            "fullscreen": "fill the browser with this window",
            "collapse": "collapse window",
            "expand": "expand window",
            "close": "close this performance",
            "changeLanguage": "change languages",
            "addLanguage": "add language",
            "removeLanguage": "remove language",
            "horizontal": "switch to horizontal arrangement",
            "vertical": "switch to vertical arrangement",
            "freeform": "switch to free form arrangement",
            "fit": "fit to content",
            "grid": "show/hide grid",
            "addPose": "add pose",
            "removePose": "remove pose",
            "movePoseUp": "move pose up",
            "movePoseDown": "move pose down",
            "addPhrase": "add a phrase after this",
            "addGroup": "add a group after this",
            "removeContent": "remove this content",
            "moveContentUp": "move this content up",
            "moveContentDown": "move this content down",
            "editContent": "edit this content",
            "sequence": "convert to a sequence",
            "animate": "toggle animations on/off",
            "addSource": "create a new $source",
            "deleteSource": "remove this $source",
            "deleteProject": "delete this performance",
            "editProject": "edit this performance",
            "settings": "show settings",
            "newProject": "new performance",
            "dark": "toggle dark mode on, off, and default",
            "chooserExpand": "expand/collapse",
            "place": "place output",
            "paint": "paint output",
            "nextLesson": "next lesson",
            "previousLesson": "previous lesson",
            "nextLessonStep": "next step",
            "previousLessonStep": "previous step",
            "revertProject": "revert to original code",
            "showOutput": "show this output on stage",
            "expandCode": "expand this collapsed code",
            "increment": "increase value by 1",
            "decrement": "decrease value by 1",
            "addInput": "add this input"
        },
        "prompt": { "deleteSource": "delete", "deleteProject": "delete" },
        "labels": {
            "learn": "learn more …",
            "nodoc": "Who am I? What am I? What is my purpose?",
            "mixed": "mixed",
            "computed": "computed",
            "default": "default",
            "inherited": "inherited",
            "notSequence": "not a sequence",
            "notContent": "not a content list",
            "anonymous": "anonymous"
        },
        "header": {
            "learn": "Learn",
            "select": "select a 💬, 🔳, or 🎭 to edit!",
            "editing": "edit me!",
            "projects": "Performances",
            "examples": "Examples",
            "inputs": "Inputs",
            "interfaces": "Interfaces",
            "properties": "Properties",
            "functions": "Functions",
            "conversions": "Conversions",
            "selectedLocales": "Selected languages …",
            "supportedLocales": "Available languages …",
            "helpLocalize": "Help us translate …"
        },
        "section": {
            "project": "performance",
            "conflicts": "conflicts",
            "timeline": "timeline",
            "toolbar": "toolbar",
            "output": "output",
            "palette": "palette",
            "editor": "code editor"
        },
        "feedback": {
            "unknownProject": "There's no performance with this ID."
        },
        "login": {
            "header": "Login",
            "prompt": "Log in to access your performances.",
            "anonymousPrompt": "Your performances are saved on this device. Create an account to save them online.",
            "submit": "send a login email",
            "enterEmail": "It looks like you're logging in on a different device. Can you enter your email again?",
            "sent": "Check your email for a link.",
            "success": "Account created!",
            "failure": "Couldn't reach the database",
            "expiredFailure": "This link expired.",
            "invalidFailure": "This link isn't valid.",
            "emailFailure": "This email wasn't valid.",
            "logout": "logout",
            "offline": "You appear to be offline."
        },
        "edit": {
            "before": "before $1",
            "inside": "inside $1",
            "add": "$2[add $2|remove $1]",
            "append": "insert $1",
            "remove": "remove $1",
            "replace": "replace with $1[$1|nothing]",
            "wrap": "parentheize",
            "unwrap": "unwrap",
            "bind": "name this expression"
        },
        "error": {
            "tutorial": "We weren't able to find a tutorial for this language.",
            "unwritten": "TBD",
            "template": "This template couldn't be parsed: $1"
        }
    }
}
