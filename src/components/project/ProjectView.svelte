<script context="module" lang="ts">
    export const PROJECT_PARAM_PLAY = 'play';
</script>

<script lang="ts">
    import { beforeUpdate, onDestroy, setContext, tick } from 'svelte';
    import { derived, writable, type Writable } from 'svelte/store';
    import {
        type DraggedContext,
        DraggedSymbol,
        ConceptIndexSymbol,
        type ConceptIndexContext,
        setSelectedOutput,
        type AnimatingNodesContext,
        type ConflictsContext,
        type SelectedOutputPathsContext,
        type SelectedPhraseContext,
        type EvaluatorContext,
        EvaluatorSymbol,
        SelectedOutputSymbol,
        SelectedPhraseSymbol,
        type SelectedOutputContext,
        ConflictsSymbol,
        AnimatingNodesSymbol,
        SelectedOutputPathsSymbol,
        type EvaluationContext,
        EvaluationSymbol,
        KeyboardEditIdleSymbol,
        InsertionsSymbol,
        type InsertionsContext,
        getConceptPath,
    } from './Contexts';
    import type Project from '@models/Project';
    import Documentation from '@components/concepts/Documentation.svelte';
    import Annotations from '../annotations/Annotations.svelte';
    import type Conflict from '@conflicts/Conflict';
    import RootView from './RootView.svelte';
    import Highlight from '../editor/Highlight.svelte';
    import { afterUpdate } from 'svelte';
    import getOutlineOf, { getUnderlineOf } from '../editor/util/outline';
    import type { HighlightSpec } from '../editor/util/Highlights';
    import TileView, { type ResizeDirection } from './TileView.svelte';
    import Tile, { Content, Mode } from './Tile';
    import OutputView from '../output/OutputView.svelte';
    import type Value from '@runtime/Value';
    import Editor from '../editor/Editor.svelte';
    import Layout, { Arrangement, DocsID, OutputID, PaletteID } from './Layout';
    import NonSourceTileToggle from './NonSourceTileToggle.svelte';
    import Button from '../widgets/Button.svelte';
    import Palette from '../palette/Palette.svelte';
    import type Bounds from './Bounds';
    import type Source from '@nodes/Source';
    import SourceTileToggle from './SourceTileToggle.svelte';
    import type MenuInfo from '../editor/util/Menu';
    import Menu from '../editor/Menu.svelte';
    import Node from '@nodes/Node';
    import ConceptIndex from '../../concepts/ConceptIndex';
    import type Concept from '../../concepts/Concept';
    import Settings from '../settings/Settings.svelte';
    import ConfirmButton from '../widgets/ConfirmButton.svelte';
    import { isName } from '@parser/Tokenizer';
    import { goto } from '$app/navigation';
    import TextField from '../widgets/TextField.svelte';
    import Status from '../app/Status.svelte';
    import Evaluator from '@runtime/Evaluator';
    import Evaluate from '@nodes/Evaluate';
    import { page } from '$app/stores';
    import type Caret from '../editor/util/Caret';
    import GlyphChooser from '../editor/GlyphChooser.svelte';
    import Timeline from '../evaluator/Timeline.svelte';
    import Painting from '../output/Painting.svelte';
    import type PaintingConfiguration from '../output/PaintingConfiguration';
    import { creator } from '../../db/Creator';

    export let project: Project;
    export let close: () => void;
    export let tip: string;
    /** If set to false, only the output is shown initially. */
    export let editable: boolean = true;
    /** True if the output should be fit to content */
    export let fit: boolean = true;
    export let autofocus: boolean = true;

    // The HTMLElement that represents this element
    let view: HTMLElement | undefined = undefined;

    // The conflicts of interest in each editor, used to generate annotations.
    let conflictsOfInterest: Map<Source, Conflict[]> = new Map();

    /** The latest menu generated by an editor */
    let menu: MenuInfo | undefined;

    /** The latest mouse position */
    let pointerX = 0;
    let pointerY = 0;

    /** The view that contains the dragged node */
    let dragContainer: HTMLElement | undefined;

    /** The outline to display under the dragged node */
    let outline: HighlightSpec | undefined = undefined;

    /** The current canvas */
    let canvas: HTMLElement;

    /** The current canvas dimensions */
    let canvasWidth: number = 1024;
    let canvasHeight: number = 768;

    /** The bound window dimensions */
    let windowWidth: number = 1;
    let windowHeight: number = 1;
    $: windowAspect =
        typeof window === 'undefined'
            ? windowWidth / windowHeight
            : window.innerWidth / window.innerHeight;

    /** The background color of the output, so we can make the tile match. */
    let outputBackground: string | null;

    /** The current tile layout */
    let layoutInitialized = false;

    /** The conflicts present in the current project. **/
    const conflicts: ConflictsContext = writable([]);

    /** Keep the project in a store so we can derive other stores from it. */
    let projectStore = writable<Project>(project);
    $: if ($projectStore !== project) projectStore.set(project);

    /** Keep a project view global store indicating whether the creator is idle. */
    const keyboardEditIdle = writable<boolean>(true);
    setContext(KeyboardEditIdleSymbol, keyboardEditIdle);
    let keyboardIdleTimeout: NodeJS.Timer | undefined = undefined;

    // When keyboard edit idle changes to true, set a timeout
    // to reset it to false after a delay.
    $: {
        if (!$keyboardEditIdle) {
            if (keyboardIdleTimeout) clearTimeout(keyboardIdleTimeout);
            keyboardIdleTimeout = setTimeout(
                () => keyboardEditIdle.set(true),
                1000
            );
        }
    }

    onDestroy(() => {
        if (keyboardIdleTimeout) clearTimeout(keyboardIdleTimeout);
    });

    /**
     * Create a project global context that stores the current selected value (and if not in an editing mode, nothing).
     * This enables output views like phrases and groups know what mode the output view is in and whether they are selected.
     * so they can render selected feedback.
     */
    const selectedOutputPaths: SelectedOutputPathsContext = writable([]);
    const selectedOutput: SelectedOutputContext = derived(
        [projectStore, selectedOutputPaths],
        ([proj, paths]) => {
            return paths
                .map(({ source, path }) => {
                    if (
                        source === undefined ||
                        path === undefined ||
                        proj === undefined
                    )
                        return undefined;
                    const name = source.getNames()[0];
                    if (name === undefined) return undefined;
                    const newSource = proj.getSourceWithName(name);
                    if (newSource === undefined) return undefined;
                    return newSource.root.resolvePath(newSource, path);
                })
                .filter(
                    (output): output is Evaluate => output instanceof Evaluate
                );
        }
    );
    const selectedPhrase: SelectedPhraseContext = writable(null);

    setContext<SelectedOutputPathsContext>(
        SelectedOutputPathsSymbol,
        selectedOutputPaths
    );
    setContext<SelectedOutputContext>(SelectedOutputSymbol, selectedOutput);
    setContext<SelectedPhraseContext>(SelectedPhraseSymbol, selectedPhrase);

    /**
     * Create a store for an evaluator for the project.
     * Make it available to children.
     * When the project changes,
     */
    const evaluator: Writable<Evaluator> = writable();

    setContext<EvaluatorContext>(EvaluatorSymbol, evaluator);

    // When the project changes, create a new evaluator, observe it.
    projectStore.subscribe((newProject) => {
        // Stop the old evaluator.
        $evaluator?.stop();

        // Make the new evaluator
        const newEvaluator = new Evaluator(newProject, $evaluator);

        // Listen to the evaluator changes to update evaluator-related stores.
        newEvaluator.observe(updateEvaluatorStores);

        // Set the evaluator store
        evaluator.set(newEvaluator);
    });

    /** Create a store for all of the evaluation state, so that the editor nodes can update when it changes. */
    const evaluation: Writable<EvaluationContext> = writable(
        getEvaluationContext()
    );
    setContext<Writable<EvaluationContext>>(EvaluationSymbol, evaluation);

    function updateEvaluatorStores() {
        evaluation.set(getEvaluationContext());
    }

    function getEvaluationContext() {
        return {
            evaluator: $evaluator,
            step: $evaluator.getCurrentStep(),
            stepIndex: $evaluator.getStepIndex(),
            playing: $evaluator.isPlaying(),
            streams: $evaluator.reactions,
        };
    }

    /** Clean up the evaluator when unmounting. */
    onDestroy(() => {
        $evaluator.stop();
    });

    /** Several store contexts for tracking evaluator state. */
    const animatingNodes: AnimatingNodesContext = writable<Set<Node>>(
        new Set()
    );

    setContext<AnimatingNodesContext>(AnimatingNodesSymbol, animatingNodes);
    setContext<ConflictsContext>(ConflictsSymbol, conflicts);

    /** A store for tracking insertions from non-Editor components in the project */
    const insertions = writable(new Map<Source, string>());
    setContext<InsertionsContext>(InsertionsSymbol, insertions);

    // Clear the selected output upon playing.
    evaluation.subscribe((val) => {
        if (val.playing) selectedOutputPaths.set([]);
    });

    function syncTiles(tiles: Tile[]): Tile[] {
        const newTiles: Tile[] = [];

        // Go through each tile and map it to a source file.
        // If we don't find it, remove the tile.
        for (const tile of tiles) {
            if (tile.kind !== Content.Source) {
                newTiles.push(tile);
            } else {
                const source = project
                    .getSources()
                    .find((_, index) => Layout.getSourceID(index) === tile.id);
                if (source)
                    newTiles.push(
                        tile
                            .withName(
                                source.names.getLocaleText(
                                    $creator.getLanguages()
                                )
                            )
                            // If not editable, keep the source files collapsed
                            .withMode(editable ? tile.mode : Mode.Collapsed)
                    );
            }
        }

        // Go through each source file and find the tile. If we don't find one, create one.
        let index = 0;
        for (const source of project.getSources()) {
            const tile = tiles.find(
                (tile) => tile.id === Layout.getSourceID(index)
            );
            if (tile === undefined)
                newTiles.push(createSourceTile(source, index));
            index++;
        }

        return newTiles;
    }

    function createSourceTile(source: Source, index: number) {
        return new Tile(
            Layout.getSourceID(index),
            source.names.getLocaleText($creator.getLanguages()),
            Content.Source,
            index === 0 ? Mode.Expanded : Mode.Collapsed,
            undefined,
            Tile.randomPosition(1024, 768)
        );
    }

    function initializedLayout() {
        const layouts = $creator.getLayout();
        const layout = layouts ? layouts[project.id] : null;
        const persistedLayout = layout ? Layout.fromObject(layout) : null;
        return persistedLayout === null
            ? null
            : persistedLayout.withTiles(syncTiles(persistedLayout.tiles));
    }

    /** Compute a default layout, or a new layout when the languages change. */
    let layout: Layout;
    $: {
        layout =
            (!layoutInitialized ? initializedLayout() : null) ??
            new Layout(
                layout
                    ? syncTiles(layout.tiles)
                    : [
                          new Tile(
                              OutputID,
                              $creator.getLocale().ui.tiles.output,
                              Content.Output,
                              Mode.Expanded,
                              undefined,
                              Tile.randomPosition(1024, 768)
                          ),
                          ...project.getSources().map((source, index) =>
                              // If not editable, collapse the source.
                              createSourceTile(source, index).withMode(
                                  editable && index === 0
                                      ? Mode.Expanded
                                      : Mode.Collapsed
                              )
                          ),
                          new Tile(
                              PaletteID,
                              $creator.getLocale().ui.tiles.palette,
                              Content.Palette,
                              Mode.Collapsed,
                              undefined,
                              Tile.randomPosition(1024, 768)
                          ),
                          new Tile(
                              DocsID,
                              $creator.getLocale().ui.tiles.docs,
                              Content.Documentation,
                              Mode.Collapsed,
                              undefined,
                              Tile.randomPosition(1024, 768)
                          ),
                      ],
                // Choose a default layout appropriate for the aspect ratio
                layout
                    ? layout.arrangement
                    : windowAspect > 1
                    ? Arrangement.horizontal
                    : Arrangement.vertical,
                layout ? layout.fullscreenID : undefined
            );

        if (
            !layoutInitialized &&
            $page.url.searchParams.get(PROJECT_PARAM_PLAY) !== null
        ) {
            const output = layout.getOutput();
            if (output) setFullscreen(output, true);
        }

        layoutInitialized = true;
    }

    /** When the layout changes, add or remove query params based on state */
    $: {
        const searchParams = new URLSearchParams($page.url.searchParams);
        if (layout.fullscreenID === Content.Output)
            searchParams.set(PROJECT_PARAM_PLAY, '');
        else searchParams.delete(PROJECT_PARAM_PLAY);
        // Update the URL, removing = for keys with no values
        const search = `${searchParams.toString().replace(/=(?=&|$)/gm, '')}`;
        const currentSearch =
            $page.url.search.charAt(0) === '?'
                ? $page.url.search.substring(1)
                : $page.url.search;
        // If the search params haven't changed, don't navigate.
        if (search !== currentSearch)
            goto(`?${search}`, { replaceState: true });
    }

    /** Persist the layout when it changes */
    $: {
        const layouts = $creator.getLayout() ?? {};
        layouts[project.id] = layout.toObject();
        $creator.setLayout(layouts);
    }

    /** The tile being dragged */
    let draggedTile:
        | {
              id: string;
              left: number;
              top: number;
              direction: ResizeDirection | null;
          }
        | undefined = undefined;

    /** The furthest boundary of a dragged tile, defining the dimensions of the canvas while in freeform layout mode. */
    let maxRight: number = 0;
    let maxBottom: number = 0;

    /* A global context for a node being dragged */
    let dragged = writable<Node | undefined>(undefined);
    setContext<DraggedContext>(DraggedSymbol, dragged);

    /** The latest value of main in the project */
    let latest: Value | undefined;

    /** True if the output should show a grid */
    let grid: boolean = false;

    /** Undefined or an object defining painting configuration */
    let painting: boolean = false;
    let paintingConfig: PaintingConfiguration = {
        characters: 'a',
        size: 1,
        font: 'Noto Sans',
    };

    /** Set up project wide concept index and path context */
    export let index: ConceptIndexContext = writable(
        new ConceptIndex([], $creator.getLocales())
    );
    setContext(ConceptIndexSymbol, index);

    let path = getConceptPath();

    let latestProject: Project | undefined;

    // When the project changes, languages change, and the keyboard is idle, recompute the concept index.
    $: {
        if ($keyboardEditIdle && latestProject !== project) {
            latestProject = project;

            // Make a new concept index with the new project and translations, but the old examples.
            const newIndex =
                project && $index
                    ? ConceptIndex.make(
                          project,
                          $creator.getLocales()
                      ).withExamples($index.examples)
                    : undefined;

            // Set the index
            index.set(newIndex);

            // Map the old path to the new one using concept equality.
            path.set(
                $index
                    ? $path
                          .map((concept) => $index?.getEquivalent(concept))
                          .filter((c): c is Concept => c !== undefined)
                    : []
            );
        }
    }

    // When the path changes, show the docs.
    let latestPath: Concept[] = $path;
    $: {
        if (
            $path.length !== latestPath.length ||
            !$path.every((concept, index) => concept === latestPath[index])
        ) {
            const docs = layout.getDocs();
            if (docs) setMode(docs, Mode.Expanded);
        }
        // Update the latest path.
        latestPath = $path;
    }

    /** Build a list of visible conflicts of interest based on what tiles are expanded. */
    $: visibleConflicts = Array.from(conflictsOfInterest.keys())
        // Get the list of sources that are expanded
        .filter(
            (source) =>
                layout.getSource(project.getIndexOfSource(source))?.mode ===
                Mode.Expanded
        )
        // Convert them into lists of conflicts
        .map((source) => conflictsOfInterest.get(source) ?? [])
        // Flatten the list
        .flat();

    /**
     * Reanalyze on a delay any time the project changes.
     * */
    let updateTimer: NodeJS.Timer | undefined = undefined;
    $: {
        // Re-evaluate immediately.
        if (!$evaluator.isStarted()) $evaluator.start();

        if (updateTimer) clearTimeout(updateTimer);
        updateTimer = setTimeout(() => {
            project.analyze();
            conflicts?.set(project.getConflicts());
        }, 300);
    }

    /** When stepping and the current step changes, change the active source. */
    $: {
        if ($evaluation.playing === false && $evaluation.step) {
            const source = project.getSourceOf($evaluation.step.node);
            const tile = source
                ? layout.getSource(project.getIndexOfSource(source))
                : undefined;
            if (tile && tile.mode === Mode.Collapsed) {
                setMode(tile, Mode.Expanded);
            }
        }
    }

    /** When output selection changes, make the palette visible. */
    $: {
        const palette = layout.getPalette();
        if (palette) {
            if ($selectedOutput && $selectedOutput.length > 0) {
                if (palette.mode === Mode.Collapsed)
                    setMode(palette, Mode.Expanded);
            } else setMode(palette, Mode.Collapsed);
        }
    }

    $: {
        if (canvasWidth && canvasHeight) {
            layout = layout.resized(canvasWidth, canvasHeight);
        }
    }

    /** Recompute the bounds based every time the layout changes. */
    $: maxRight = Math.max.apply(undefined, [
        maxRight,
        ...layout.tiles.map((tile) => tile.position.left + tile.position.width),
    ]);
    $: maxBottom = Math.max.apply(undefined, [
        maxBottom,
        ...layout.tiles.map((tile) => tile.position.top + tile.position.height),
    ]);

    /** When the program steps language changes, get the latest value of the program's evaluation. */
    $: {
        $evaluation;
        $creator.getLanguages();
        latest = $evaluator.getLatestSourceValue(project.main);
    }

    /**
     * When the layout changes, create an ID to key off of when generating tile views.
     * This is necessary because of a defect in Svelte's keyed each behavior, which
     * doesn't appear to be able to handle swaps in a list.
     */
    $: tileIDSequence = layout.tiles.map((tile) => tile.id).join(',');

    /** If the source file corresponding to the menu closes, hide the menu. */
    $: {
        if (menu) {
            // Find the tile corresponding to the menu's source file.
            const index = project.getSources().indexOf(menu.caret.source);
            const tile = layout.tiles.find(
                (tile) => tile.id === Layout.getSourceID(index)
            );
            if (tile && tile.isCollapsed()) menu = undefined;
        }
    }

    /** When the menu changes, compute a menu position. */
    $: menuPosition = menu ? getMenuPosition(menu.caret) : undefined;

    /** Before each update, note which tile has focus */
    let focusedTileID: string | undefined = undefined;
    beforeUpdate(() => {
        focusedTileID = undefined;
        const focus = document.activeElement;
        if (focus && view && view.contains(focus)) {
            const tile = focus.closest('.tile');
            if (tile instanceof HTMLElement && tile.dataset.id)
                focusedTileID = tile.dataset.id;
        }
    });

    afterUpdate(() => {
        /** After each update, measure an outline of the node view in the drag container. */
        const nodeView = dragContainer?.querySelector('.node-view');
        if (nodeView instanceof HTMLElement)
            outline = {
                types: ['dragging'],
                outline: getOutlineOf(nodeView),
                underline: getUnderlineOf(nodeView),
            };

        /** Restore focus if on body */
        if (document.activeElement === document.body && focusedTileID)
            tick().then(() => focusTile(focusedTileID));
    });

    function focusTile(focusedTileID: string | undefined) {
        if (view === undefined || view === null) return;

        const firstTileID = layout.tiles.find(
            (tile) => !tile.isCollapsed()
        )?.id;
        const focusedTileView = focusedTileID
            ? view.querySelector(`.tile[data-id="${focusedTileID}"]`)
            : null;
        const firstTileView = firstTileID
            ? view.querySelector(`.tile[data-id="${firstTileID}"]`)
            : undefined;
        const tileView = focusedTileView ?? firstTileView;

        // The output view handles its own focus management, so if we're focusing on it,
        // and it's still in view, don't mess with it.
        if (
            focusedTileID === OutputID &&
            focusedTileView !== null &&
            focusedTileView.contains(document.activeElement)
        )
            return;

        let viewToFocus: HTMLElement | undefined = undefined;
        if (tileView) {
            const defaultFocus = tileView.querySelectorAll(
                '[data-defaultfocus]'
            )[0];
            if (defaultFocus instanceof HTMLElement) viewToFocus = defaultFocus;
            else {
                const focusable = tileView.querySelectorAll(
                    'input, button, [tabindex="0"]'
                )[0];
                if (focusable instanceof HTMLElement) viewToFocus = focusable;
            }
        }
        // No tiles visible? Just focus on the project view.
        (viewToFocus ?? view).focus();
    }

    function setMode(tile: Tile, mode: Mode) {
        if (layout.getTileWithID(tile.id)?.mode === mode) return;

        // Special case selected output and the palette.
        if (
            tile === layout.getPalette() &&
            $selectedOutput &&
            selectedOutputPaths
        ) {
            if (tile.mode === Mode.Collapsed && $selectedOutput.length === 0) {
                const output = project.getOutput();
                if (output.length > 0)
                    setSelectedOutput(selectedOutputPaths, project, [
                        output[0],
                    ]);
            } else if (tile.mode === Mode.Expanded) {
                setSelectedOutput(selectedOutputPaths, project, []);
            }
        }

        layout = layout
            .withTileLast(tile.withMode(mode))
            .resized(canvasWidth, canvasHeight);
    }

    function setFullscreen(tile: Tile, fullscreen: boolean) {
        layout = fullscreen
            ? layout.withFullscreen(tile.id)
            : layout.withoutFullscreen();
    }

    async function positionTile(tile: Tile, position: Bounds) {
        layout = layout.withTilePosition(tile, position);

        // Scroll tile into view if out
        await tick();
        if (draggedTile) scrollToTileView(tile.id);
    }

    function handlePointerDown(event: PointerEvent) {
        if (layout.arrangement === Arrangement.free) {
            const tileView = document
                .elementFromPoint(event.clientX, event.clientY)
                ?.closest('.tile');

            if (tileView instanceof HTMLElement && tileView.dataset.id) {
                const rect = tileView.getBoundingClientRect();
                const id = tileView.dataset.id;

                draggedTile = {
                    id: id,
                    left: event.clientX - rect.left,
                    top: event.clientY - rect.top,
                    direction: null,
                };

                const tile = layout.getTileWithID(id);
                if (tile) layout = layout.withTileLast(tile);
            }
        }

        // Find the tile clicked and focus it.
        const el = document.elementFromPoint(event.clientX, event.clientY);
        if (el) {
            const tile = el.closest('.tile');
            if (tile instanceof HTMLElement) focusTile(tile.dataset.id);
        }
    }

    async function handlePointerMove(event: PointerEvent) {
        pointerX = event.clientX + canvas.scrollLeft;
        pointerY = event.clientY + canvas.scrollTop;

        if (draggedTile) {
            const tile = layout.getTileWithID(draggedTile.id);
            if (tile) {
                let newBounds;
                if (draggedTile.direction === null) {
                    newBounds = {
                        left: pointerX - draggedTile.left,
                        top: pointerY - draggedTile.top,
                        width: tile.position.width,
                        height: tile.position.height,
                    };
                } else {
                    const left = draggedTile.direction.includes('left');
                    const top = draggedTile.direction.includes('top');
                    const right = draggedTile.direction.includes('right');
                    const bottom = draggedTile.direction.includes('bottom');
                    newBounds = {
                        left: left ? pointerX : tile.position.left,
                        top: top ? pointerY : tile.position.top,
                        width: left
                            ? tile.position.width +
                              (tile.position.left - pointerX)
                            : right
                            ? pointerX - tile.position.left
                            : tile.position.width,
                        height: top
                            ? tile.position.height +
                              (tile.position.top - pointerY)
                            : bottom
                            ? pointerY - tile.position.top
                            : tile.position.height,
                    };
                }
                if (newBounds) {
                    layout = layout.withTilePosition(tile, newBounds);

                    // Scroll tile into view if out
                    await tick();
                    if (draggedTile) scrollToTileView(draggedTile.id);
                }
            }
        }
    }

    function scrollToTileView(id: string) {
        const view = document.querySelector(`.tile[data-id=${id}]`);
        if (view) {
            const canvasRect = canvas.getBoundingClientRect();
            const tileRect = view.getBoundingClientRect();
            const threshold = 50;
            if (tileRect.right > canvasRect.right + threshold)
                canvas.scrollLeft = canvas.scrollLeft + threshold / 2;
            if (tileRect.bottom > canvasRect.bottom + threshold)
                canvas.scrollTop = canvas.scrollTop + threshold / 2;
            if (tileRect.left < canvasRect.left - threshold)
                canvas.scrollLeft = canvas.scrollLeft - threshold / 2;
            if (tileRect.top < canvasRect.top - threshold)
                canvas.scrollTop = canvas.scrollTop - threshold / 2;
        }
    }

    function handlePointerUp() {
        dragged.set(undefined);
        draggedTile = undefined;
    }

    function resizeTile(
        id: string,
        direction: ResizeDirection,
        left: number,
        top: number
    ) {
        draggedTile = {
            id,
            left,
            top,
            direction,
        };
    }

    function repositionFloaters() {
        conflictsOfInterest = new Map(conflictsOfInterest);
        menu = menu;
    }

    function getSourceByID(id: string) {
        return project.getSources()[parseInt(id.replace('source', ''))];
    }

    function handleKey(event: KeyboardEvent) {
        const key = event.key;
        const command = event.ctrlKey || event.metaKey;
        const alt = event.altKey;
        const shift = event.shiftKey;

        if (key === 'Escape') {
            if (command) close();
            else layout = layout.withoutFullscreen();
            return;
        }
        if (key === 'Tab' && alt) {
            layout =
                layout.arrangement === Arrangement.vertical
                    ? layout.withArrangement(Arrangement.horizontal)
                    : layout.arrangement === Arrangement.horizontal
                    ? layout.withArrangement(Arrangement.free)
                    : layout.withArrangement(Arrangement.vertical);
            return;
        }
        if (key === 'Enter' && command) {
            // Shift also? Reset
            if (event.shiftKey)
                $creator.reviseProject(project, project.clone());
            // Alt also? Full screen.
            else if (event.altKey) {
                layout = layout.isFullscreen()
                    ? layout.withoutFullscreen()
                    : layout.withFullscreen(OutputID);
                view?.focus();
            }
            // No shift or alt, and not full screen? Toggle between playing and pausing.
            else if ($evaluator.isPlaying() && !layout.isFullscreen())
                $evaluator.pause();
            else $evaluator.play();
            event.preventDefault();
            return;
        }
        if (key === 'z' && command) {
            if (shift) $creator.redoProject(project.id);
            else $creator.undoProject(project.id);
            event.preventDefault();
            event.stopPropagation();
            return;
        }

        // When in stepping mode, or when command is pressed
        if (command) {
            if (key === 'ArrowLeft') {
                // To start
                if (event.ctrlKey && event.shiftKey) $evaluator.stepTo(0);
                // To previous input
                else if (event.shiftKey) $evaluator.stepBackToInput();
                // To previous step
                else $evaluator.stepBackWithinProgram();
                event.preventDefault();
            } else if (key === 'ArrowRight') {
                // To start
                if (event.ctrlKey && event.shiftKey) $evaluator.stepToEnd();
                // To next input
                else if (event.shiftKey) $evaluator.stepToInput();
                // To next step
                else $evaluator.stepWithinProgram();
                event.preventDefault();
            }
            return;
        }
    }

    function getMenuPosition(caret: Caret) {
        // Find the editor
        const editor = document.querySelector(
            `.editor[data-id="${caret.source.id}"]`
        );
        if (editor === null) return undefined;

        // Is it a node? Position near it's top left.
        if (caret.position instanceof Node) {
            const view = editor.querySelector(
                `.node-view[data-id="${caret.position.id}"]`
            );
            if (view == null) return undefined;
            const rect = view.getBoundingClientRect();
            return {
                left: rect.left,
                top: rect.bottom,
            };
        }
        // Is it a position? Position at the bottom right of the caret.
        else if (caret.isIndex()) {
            // Find the position of the caret in the editor.
            const view = editor.querySelector('.caret');
            if (view === null) return undefined;
            const rect = view.getBoundingClientRect();
            return {
                left: rect.left,
                top: rect.bottom,
            };
        }
    }

    function toggleTile(tile: Tile) {
        setMode(
            tile,
            tile.mode === Mode.Expanded ? Mode.Collapsed : Mode.Expanded
        );
    }

    function addSource() {
        $creator.reviseProject(
            project,
            project.withNewSource(
                `${$creator.getLocale().terminology.source}${
                    project.supplements.length + 1
                }`
            )
        );
    }

    function removeSource(source: Source) {
        $creator.reviseProject(project, project.withoutSource(source));
    }

    function renameSource(id: string, name: string) {
        if (!isName(name)) return;
        const source = getSourceByID(id);
        $creator.reviseProject(
            project,
            project.withSource(
                source,
                source.withName(name, $creator.getLanguages()[0])
            )
        );
    }
</script>

<svelte:head><title>Wordplay - {project.name}</title></svelte:head>

<svelte:window
    bind:innerWidth={windowWidth}
    bind:innerHeight={windowHeight}
    on:keydown={handleKey}
/>

<!-- Render the app header and the current project, if there is one. -->
<main class="project" bind:this={view}>
    <div
        class="canvas"
        on:pointerdown={handlePointerDown}
        on:pointerup={handlePointerUp}
        on:pointermove={handlePointerMove}
        on:transitionend={repositionFloaters}
        on:scroll={repositionFloaters}
        bind:clientWidth={canvasWidth}
        bind:clientHeight={canvasHeight}
        bind:this={canvas}
    >
        <!-- This little guy enables the scroll bars to appear at the furthest extent a window has moved. -->
        {#if layout.arrangement === Arrangement.free}
            <div
                class="boundary"
                style:left="{maxRight}px"
                style:top="{maxBottom}px"
                style:position="absolute">&nbsp;</div
            >
        {/if}

        {#key tileIDSequence}
            {#if layout.tiles.every((tile) => tile.isCollapsed())}
                <div class="empty">⬇️</div>
            {:else}
                {#each layout.tiles as tile (tile.id)}
                    {#if tile.isExpanded() && (layout.fullscreenID === undefined || layout.fullscreenID === tile.id)}
                        <TileView
                            {tile}
                            {layout}
                            arrangement={layout.arrangement}
                            background={tile.kind === Content.Output
                                ? outputBackground
                                : null}
                            dragging={draggedTile?.id === tile.id}
                            fullscreenID={layout.fullscreenID}
                            on:mode={(event) =>
                                setMode(tile, event.detail.mode)}
                            on:position={(event) =>
                                positionTile(tile, event.detail.position)}
                            on:resize={(event) =>
                                resizeTile(
                                    event.detail.id,
                                    event.detail.direction,
                                    event.detail.left,
                                    event.detail.top
                                )}
                            on:scroll={repositionFloaters}
                            on:rename={(event) =>
                                renameSource(
                                    event.detail.id,
                                    event.detail.name
                                )}
                            on:fullscreen={(event) =>
                                setFullscreen(tile, event.detail.fullscreen)}
                        >
                            <svelte:fragment slot="extra">
                                {#if tile.kind === Content.Output}
                                    {#if !$evaluation.evaluator.isPlaying()}<Painting
                                            bind:painting
                                        />{/if}<Button
                                        tip={$creator.getLocale().ui.tooltip
                                            .grid}
                                        action={() => (grid = !grid)}>▦</Button
                                    ><Button
                                        tip={$creator.getLocale().ui.tooltip
                                            .fit}
                                        action={() => (fit = !fit)}
                                        >{#if fit}🔒{:else}🔓{/if}</Button
                                    >
                                {:else if tile.isSource()}
                                    {@const source = getSourceByID(tile.id)}
                                    {#if source !== project.main}
                                        <ConfirmButton
                                            tip={$creator.getLocale().ui.tooltip
                                                .deleteSource}
                                            action={() => removeSource(source)}
                                            prompt={$creator.getLocale().ui
                                                .prompt.deleteSource}
                                            >⨉</ConfirmButton
                                        >
                                    {/if}
                                {/if}
                            </svelte:fragment>
                            <svelte:fragment slot="content">
                                {#if tile.kind === Content.Documentation}
                                    <Documentation {project} />
                                {:else if tile.kind === Content.Palette}
                                    <Palette {project} />
                                {:else if tile.kind === Content.Output}
                                    <OutputView
                                        {project}
                                        evaluator={$evaluator}
                                        source={project.main}
                                        {latest}
                                        fullscreen={layout.fullscreenID ===
                                            tile.id}
                                        bind:fit
                                        bind:grid
                                        bind:painting
                                        {paintingConfig}
                                        bind:background={outputBackground}
                                    />
                                {:else}
                                    <Editor
                                        {project}
                                        evaluator={$evaluator}
                                        source={getSourceByID(tile.id)}
                                        autofocus={autofocus &&
                                            tile.isExpanded() &&
                                            getSourceByID(tile.id) ===
                                                project.main}
                                        bind:menu
                                        on:conflicts={(event) =>
                                            (conflictsOfInterest =
                                                conflictsOfInterest.set(
                                                    event.detail.source,
                                                    event.detail.conflicts
                                                ))}
                                    />
                                {/if}</svelte:fragment
                            ><svelte:fragment slot="footer"
                                >{#if tile.kind === Content.Source}<GlyphChooser
                                        source={getSourceByID(tile.id)}
                                    />{:else if tile.kind === Content.Output && layout.fullscreenID !== tile.id && editable}
                                    <Timeline
                                        evaluator={$evaluator}
                                    />{/if}</svelte:fragment
                            ></TileView
                        >
                    {/if}
                {/each}
            {/if}
        {/key}
    </div>

    {#if !layout.isFullscreen()}
        <nav class="footer">
            {#if editable}
                <Status />
                <TextField
                    placeholder={$creator.getLocale().ui.placeholders.project}
                    text={project.name}
                    border={false}
                    changed={(name) =>
                        $creator.reviseProject(project, project.withName(name))}
                />
                <Button
                    tip={layout.arrangement === Arrangement.free
                        ? $creator.getLocale().ui.tooltip.vertical
                        : layout.arrangement === Arrangement.vertical
                        ? $creator.getLocale().ui.tooltip.horizontal
                        : $creator.getLocale().ui.tooltip.freeform}
                    action={() =>
                        (layout = layout.withNextArrangement(
                            canvasWidth,
                            canvasHeight
                        ))}
                    >{#if layout.arrangement === Arrangement.vertical}↕️{:else if layout.arrangement === Arrangement.horizontal}↔️{:else if layout.arrangement === Arrangement.free}█{/if}</Button
                >
                {#each layout.getNonSources() as tile}
                    {#if tile.isCollapsed()}
                        <NonSourceTileToggle
                            {tile}
                            on:toggle={() => toggleTile(tile)}
                        />
                    {/if}
                {/each}
                {#each project.getSources() as source, index}
                    {@const tile = layout.getTileWithID(
                        Layout.getSourceID(index)
                    )}
                    {#if tile && tile.isCollapsed()}
                        <!-- Mini source view output is visible when collapsed, or if its main, when output is collapsed. -->
                        <SourceTileToggle
                            {project}
                            evaluator={$evaluator}
                            {source}
                            output={source === project.main
                                ? layout.getOutput()?.mode === Mode.Collapsed
                                : tile.mode === Mode.Collapsed}
                            expanded={tile.mode === Mode.Expanded}
                            on:toggle={() => toggleTile(tile)}
                        />
                    {/if}
                {/each}
                <Button
                    tip={$creator.getLocale().ui.tooltip.addSource}
                    action={addSource}>+</Button
                >
            {/if}

            <div class="settings">
                <Settings />
                <Button {tip} action={close}>❌</Button>
            </div>
        </nav>

        <!-- Render annotations on top of the tiles and the footer, unless dragging -->
        {#if $dragged === undefined}
            <Annotations
                {project}
                evaluator={$evaluator}
                conflicts={visibleConflicts}
                stepping={$evaluation.playing === false}
            />
        {/if}

        <!-- Render the menu on top of the annotations -->
        {#if menu && menuPosition}
            <Menu {menu} position={menuPosition} />
        {/if}

        <!-- Render the dragged node over the whole project -->
        {#if $dragged !== undefined}
            <!-- Render the highlight underneath the code -->
            <div class="drag-outline">
                {#if outline}<Highlight {...outline} above={false} />{/if}
            </div>
            <div
                class="drag-container dragging"
                style="left: {pointerX}px; top:{pointerY}px;"
                bind:this={dragContainer}
            >
                <RootView
                    node={$dragged}
                    spaces={project.getSourceOf($dragged)?.spaces}
                />
                <div class="cursor">🐲</div>
            </div>
        {/if}
    {/if}
</main>

<style>
    .project {
        flex-grow: 1;
        justify-self: center;
        background-color: var(--wordplay-background);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .project:focus:after {
        width: 100%;
        height: 100%;
        content: '';
        outline: var(--wordplay-highlight) solid var(--wordplay-focus-width);
        outline-offset: calc(-1 * var(--wordplay-focus-width));
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }

    .canvas {
        flex: 1;
        overflow: scroll;
    }

    nav {
        display: flex;
        flex-direction: row;
        align-items: center;
        flex-wrap: nowrap;
        padding: var(--wordplay-spacing);
        gap: var(--wordplay-spacing);
        border-top: var(--wordplay-border-width) solid
            var(--wordplay-border-color);
    }

    .settings {
        margin-left: auto;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: var(--wordplay-spacing);
    }

    .drag-outline {
        z-index: 2;
    }

    .drag-container {
        position: absolute;
        cursor: none;
        pointer-events: none;
        z-index: 2;
    }

    /* A fancy dragon cursor for dragon drop! Get it? */
    .cursor {
        position: absolute;
        font-size: 2rem;
        top: -1.5rem;
        left: -1.5rem;
        font-family: 'Noto Sans', 'Noto Emoji';
        pointer-events: none;
    }

    .drag-container :global(.token-view) {
        color: var(--wordplay-background);
    }

    .empty {
        width: 100%;
        height: 100%;
        color: var(--wordplay-border-color);
        font-size: 1000%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
</style>
