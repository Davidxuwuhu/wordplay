<script lang="ts">
    import { onDestroy, setContext, tick } from 'svelte';
    import { writable } from 'svelte/store';
    import {
        type DraggedContext,
        DraggedSymbol,
        ConceptIndexSymbol,
        ConceptPathSymbol,
        type ConceptPathContext,
        type ConceptIndexContext,
        getSelectedOutput,
        getPlaying,
        getCurrentStep,
        getConflicts,
        getProjects,
        setSelectedOutput,
        getSelectedOutputPaths,
    } from './Contexts';
    import type Project from '@models/Project';
    import Documentation from '@components/concepts/Documentation.svelte';
    import type Tree from '@nodes/Tree';
    import { getAnimationDuration } from '@models/stores';
    import Annotations from '../annotations/Annotations.svelte';
    import type Conflict from '@conflicts/Conflict';
    import RootView from './RootView.svelte';
    import Highlight from '../editor/Highlight.svelte';
    import { afterUpdate } from 'svelte';
    import getOutlineOf, { getUnderlineOf } from '../editor/util/outline';
    import type { HighlightSpec } from '../editor/util/Highlights';
    import { fade } from 'svelte/transition';
    import TileView, { type ResizeDirection } from './TileView.svelte';
    import Tile, { Content, Mode } from './Tile';
    import OutputView from '../output/OutputView.svelte';
    import {
        preferredLanguages,
        preferredTranslations,
    } from '@translation/translations';
    import type Value from '@runtime/Value';
    import Editor from '../editor/Editor.svelte';
    import Layout, {
        Arrangement,
        DocsID,
        OutputID,
        PaletteID,
        type LayoutObject,
    } from './Layout';
    import NonSourceTileToggle from './NonSourceTileToggle.svelte';
    import Button from '../widgets/Button.svelte';
    import Palette from '../palette/Palette.svelte';
    import type Bounds from './Bounds';
    import type Source from '@nodes/Source';
    import MiniSourceView from './SourceTileToggle.svelte';
    import Timeline from '../evaluator/Timeline.svelte';
    import type MenuInfo from '../editor/util/Menu';
    import Menu from '../editor/Menu.svelte';
    import type Caret from '../editor/util/Caret';
    import Node from '@nodes/Node';
    import Controls from '../evaluator/Controls.svelte';
    import ConceptIndex from '../../concepts/ConceptIndex';
    import KeyboardIdle from '../editor/util/KeyboardIdle';
    import type Concept from '../../concepts/Concept';
    import Settings from '../settings/Settings.svelte';
    import { getPersistedValue, setPersistedValue } from '../app/persist';
    import ConfirmButton from '../widgets/ConfirmButton.svelte';
    import { isName } from '../../parser/Tokenizer';
    import { goto } from '$app/navigation';
    import TextField from '../widgets/TextField.svelte';
    import Status from '../app/Status.svelte';

    export let project: Project;

    const projects = getProjects();
    const selectedOutput = getSelectedOutput();
    const selectedOutputPaths = getSelectedOutputPaths();
    const playing = getPlaying();
    const currentStep = getCurrentStep();
    const conflicts = getConflicts();

    // The HTMLElement that represents this element
    let view: HTMLElement | undefined = undefined;

    // The conflicts of interest in each editor, used to generate annotations.
    let conflictsOfInterest: Map<Source, Conflict[]> = new Map();

    /** The latest menu generated by an editor */
    let menu: MenuInfo | undefined;

    /** The latest mouse position */
    let mouseX = 0;
    let mouseY = 0;

    /** The view that contains the dragged node */
    let dragContainer: HTMLElement | undefined;

    /** The outline to display under the dragged node */
    let outline: HighlightSpec | undefined = undefined;

    /** The current canvas */
    let canvas: HTMLElement;

    /** The current canvas dimensions */
    let canvasWidth: number = 1024;
    let canvasHeight: number = 768;

    /** The background color of the output, so we can make the tile match. */
    let outputBackground: string | null;

    /** The current tile layout */
    const LAYOUT_KEY = 'layout';
    let layoutInitialized = false;

    function syncTiles(tiles: Tile[]): Tile[] {
        const newTiles: Tile[] = [];

        // Go through each tile and map it to a source file.
        // If we don't find it, remove the tile.
        for (const tile of tiles) {
            if (tile.kind !== Content.Source) {
                newTiles.push(tile);
            } else {
                const source = project
                    .getSources()
                    .find((_, index) => Layout.getSourceID(index) === tile.id);
                if (source)
                    newTiles.push(
                        tile.withName(
                            source.names.getTranslation($preferredLanguages)
                        )
                    );
            }
        }

        // Go through each source file and find the tile. If we don't find one, create one.
        let index = 0;
        for (const source of project.getSources()) {
            const tile = tiles.find(
                (tile) => tile.id === Layout.getSourceID(index)
            );
            if (tile === undefined)
                newTiles.push(createSourceTile(source, index));
            index++;
        }

        return newTiles;
    }

    function createSourceTile(source: Source, index: number) {
        return new Tile(
            Layout.getSourceID(index),
            source.names.getTranslation($preferredLanguages),
            Content.Source,
            index === 0 ? Mode.Expanded : Mode.Collapsed,
            undefined,
            Tile.randomPosition(1024, 768)
        );
    }

    function initializedLayout() {
        const persistedLayout = Layout.fromObject(
            project.name,
            getPersistedValue<LayoutObject>(LAYOUT_KEY)
        );
        if (persistedLayout === null) return null;

        return persistedLayout.withTiles(syncTiles(persistedLayout.tiles));
    }

    /** Compute a default layout, or a new layout when the languages change. */
    let layout: Layout;
    $: {
        layout =
            (!layoutInitialized ? initializedLayout() : null) ??
            new Layout(
                layout
                    ? syncTiles(layout.tiles)
                    : [
                          new Tile(
                              OutputID,
                              $preferredTranslations[0].ui.tiles.output,
                              Content.Output,
                              Mode.Expanded,
                              undefined,
                              Tile.randomPosition(1024, 768)
                          ),
                          ...project
                              .getSources()
                              .map((source, index) =>
                                  createSourceTile(source, index)
                              ),
                          new Tile(
                              PaletteID,
                              $preferredTranslations[0].ui.tiles.palette,
                              Content.Palette,
                              Mode.Collapsed,
                              undefined,
                              Tile.randomPosition(1024, 768)
                          ),
                          new Tile(
                              DocsID,
                              $preferredTranslations[0].ui.tiles.docs,
                              Content.Documentation,
                              Mode.Collapsed,
                              undefined,
                              Tile.randomPosition(1024, 768)
                          ),
                      ],
                layout ? layout.arrangement : Arrangement.vertical,
                layout ? layout.fullscreenID : undefined
            );
        layoutInitialized = true;
    }

    /** Persist the layout when it changes */
    $: setPersistedValue(LAYOUT_KEY, layout.toObject(project.name));

    /** The tile being dragged */
    let draggedTile:
        | {
              id: string;
              left: number;
              top: number;
              direction: ResizeDirection | null;
          }
        | undefined = undefined;

    /** The furthest boundary of a dragged tile, defining the dimensions of the canvas. */
    let maxRight: number = 0;
    let maxBottom: number = 0;

    /* A global context for a node being dragged */
    let dragged = writable<Tree | undefined>(undefined);
    setContext<DraggedContext>(DraggedSymbol, dragged);

    /** The latest value of main in the project */
    let latest: Value | undefined;

    /** True if the output should be fit to content */
    let fit: boolean = true;

    /** True if the output should show a grid */
    let grid: boolean = false;

    /** Set up project wide concept index and path context */
    let index: ConceptIndexContext = writable(
        new ConceptIndex([], $preferredTranslations)
    );
    setContext(ConceptIndexSymbol, index);
    let path: ConceptPathContext = writable([]);
    setContext(ConceptPathSymbol, path);

    let latestProject: Project | undefined;

    // When the project changes, languages change, and the keyboard is idle, recompute the concept index.
    $: {
        if ($KeyboardIdle && latestProject !== project) {
            latestProject = project;

            // Make a new concept index with the new project and translations, but the old examples.
            const newIndex =
                project && $index
                    ? ConceptIndex.make(
                          project,
                          $preferredTranslations
                      ).withExamples($index.examples)
                    : undefined;

            // Set the index
            index.set(newIndex);

            // Map the old path to the new one using concept equality.
            path.set(
                $index
                    ? $path
                          .map((concept) => $index?.getEquivalent(concept))
                          .filter((c): c is Concept => c !== undefined)
                    : []
            );
        }
    }

    // When the path changes, show the docs.
    let latestPath: Concept[] = $path;
    $: {
        if (
            $path.length !== latestPath.length ||
            !$path.every((concept, index) => concept === latestPath[index])
        ) {
            const docs = layout.getDocs();
            if (docs) setMode(docs, Mode.Expanded);
        }
        // Update the latest path.
        latestPath = $path;
    }

    /** When the project changes, reset the conflicts map. */
    $: if (project) conflictsOfInterest = new Map();

    /** Build a list of visible conflicts of interest based on what tiles are expanded. */
    $: visibleConflicts = Array.from(conflictsOfInterest.keys())
        // Get the list of sources that are expanded
        .filter(
            (source) =>
                layout.getSource(project.getIndexOfSource(source))?.mode ===
                Mode.Expanded
        )
        // Convert them into lists of conflicts
        .map((source) => conflictsOfInterest.get(source) ?? [])
        // Flatten the list
        .flat();

    /**
     * Reanalyze on a delay any time the project changes.
     * */
    let updateTimer: NodeJS.Timer | undefined = undefined;
    $: {
        // Re-evaluate immediately.
        if (!project.evaluator.isStarted()) project.evaluate();

        if (updateTimer) clearTimeout(updateTimer);
        updateTimer = setTimeout(() => {
            project.analyze();
            conflicts?.set(project.getConflicts());
        }, 300);
    }

    /** When stepping and the current step changes, change the active source. */
    $: {
        if (!$playing && $currentStep) {
            const source = project.getSourceOf($currentStep.node);
            const tile = source
                ? layout.getSource(project.getIndexOfSource(source))
                : undefined;
            if (tile && tile.mode === Mode.Collapsed) {
                setMode(tile, Mode.Expanded);
            }
        }
    }

    /** When output selection changes, make the palette visible. */
    $: {
        const palette = layout.getPalette();
        if (palette) {
            if ($selectedOutput && $selectedOutput.length > 0) {
                if (palette.mode === Mode.Collapsed)
                    setMode(palette, Mode.Expanded);
            } else setMode(palette, Mode.Collapsed);
        }
    }

    $: {
        if (canvasWidth && canvasHeight) {
            layout = layout.resized(canvasWidth, canvasHeight);
        }
    }

    /** Recompute the bounds based every time the layout changes. */
    $: maxRight = Math.max.apply(undefined, [
        maxRight,
        ...layout.tiles.map((tile) => tile.position.left + tile.position.width),
    ]);
    $: maxBottom = Math.max.apply(undefined, [
        maxBottom,
        ...layout.tiles.map((tile) => tile.position.top + tile.position.height),
    ]);

    /** When the program steps language changes, get the latest value of the program's evaluation. */
    $: {
        $currentStep;
        $preferredLanguages;
        latest = project.evaluator.getLatestSourceValue(project.main);
    }

    /**
     * When the layout changes, create an ID to key off of when generating tile views.
     * This is necessary because of a defect in Svelte's keyed each behavior, which
     * doesn't appear to be able to handle swaps in a list.
     */
    $: tileIDSequence = layout.tiles.map((tile) => tile.id).join(',');

    /** If the source file corresponding to the menu closes, hide the menu. */
    $: {
        if (menu) {
            // Find the tile corresponding to the menu's source file.
            const index = project.getSources().indexOf(menu.caret.source);
            const tile = layout.tiles.find(
                (tile) => tile.id === Layout.getSourceID(index)
            );
            if (tile && tile.isCollapsed()) menu = undefined;
        }
    }

    /** When the menu changes, compute a menu position. */
    $: menuPosition = menu ? getMenuPosition(menu.caret) : undefined;

    /** After each update, measure an outline of the node view in the drag container. */
    afterUpdate(() => {
        const nodeView = dragContainer?.querySelector('.node-view');
        if (nodeView instanceof HTMLElement)
            outline = {
                types: ['dragging'],
                outline: getOutlineOf(nodeView),
                underline: getUnderlineOf(nodeView),
            };
    });

    /** Clean up the project when this is unmounted. */
    onDestroy(() => project.cleanup());

    function setMode(tile: Tile, mode: Mode) {
        if (layout.getTileWithID(tile.id)?.mode === mode) return;

        layout = layout
            .withTileLast(tile.withMode(mode))
            .resized(canvasWidth, canvasHeight);

        if (mode === Mode.Collapsed) view?.focus();
    }

    function setFullscreen(tile: Tile, fullscreen: boolean) {
        layout = fullscreen
            ? layout.withFullscreen(tile.id)
            : layout.withoutFullscreen();
    }

    async function positionTile(tile: Tile, position: Bounds) {
        layout = layout.withTilePosition(tile, position);

        // Scroll tile into view if out
        await tick();
        if (draggedTile) scrollToTileView(tile.id);
    }

    function handleMouseDown(event: MouseEvent) {
        if (layout.arrangement !== Arrangement.free) return;

        const tileView = document
            .elementFromPoint(event.clientX, event.clientY)
            ?.closest('.tile');

        if (tileView instanceof HTMLElement && tileView.dataset.id) {
            const rect = tileView.getBoundingClientRect();
            const id = tileView.dataset.id;

            draggedTile = {
                id: id,
                left: event.clientX - rect.left,
                top: event.clientY - rect.top,
                direction: null,
            };

            const tile = layout.getTileWithID(id);
            if (tile) layout = layout.withTileLast(tile);
        }
    }

    async function handleMouseMove(event: MouseEvent) {
        mouseX = event.clientX + canvas.scrollLeft;
        mouseY = event.clientY + canvas.scrollTop;

        if (draggedTile) {
            const tile = layout.getTileWithID(draggedTile.id);
            if (tile) {
                let newBounds;
                if (draggedTile.direction === null) {
                    newBounds = {
                        left: mouseX - draggedTile.left,
                        top: mouseY - draggedTile.top,
                        width: tile.position.width,
                        height: tile.position.height,
                    };
                } else {
                    const left = draggedTile.direction.includes('left');
                    const top = draggedTile.direction.includes('top');
                    const right = draggedTile.direction.includes('right');
                    const bottom = draggedTile.direction.includes('bottom');
                    newBounds = {
                        left: left ? mouseX : tile.position.left,
                        top: top ? mouseY : tile.position.top,
                        width: left
                            ? tile.position.width +
                              (tile.position.left - mouseX)
                            : right
                            ? mouseX - tile.position.left
                            : tile.position.width,
                        height: top
                            ? tile.position.height +
                              (tile.position.top - mouseY)
                            : bottom
                            ? mouseY - tile.position.top
                            : tile.position.height,
                    };
                }
                if (newBounds) {
                    layout = layout.withTilePosition(tile, newBounds);

                    // Scroll tile into view if out
                    await tick();
                    if (draggedTile) scrollToTileView(draggedTile.id);
                }
            }
        }
    }

    function scrollToTileView(id: string) {
        const view = document.querySelector(`.tile[data-id=${id}]`);
        if (view) {
            const canvasRect = canvas.getBoundingClientRect();
            const tileRect = view.getBoundingClientRect();
            const threshold = 50;
            if (tileRect.right > canvasRect.right + threshold)
                canvas.scrollLeft = canvas.scrollLeft + threshold / 2;
            if (tileRect.bottom > canvasRect.bottom + threshold)
                canvas.scrollTop = canvas.scrollTop + threshold / 2;
            if (tileRect.left < canvasRect.left - threshold)
                canvas.scrollLeft = canvas.scrollLeft - threshold / 2;
            if (tileRect.top < canvasRect.top - threshold)
                canvas.scrollTop = canvas.scrollTop - threshold / 2;
        }
    }

    function handleMouseUp() {
        dragged.set(undefined);
        draggedTile = undefined;
    }

    function resizeTile(
        id: string,
        direction: ResizeDirection,
        left: number,
        top: number
    ) {
        draggedTile = {
            id,
            left,
            top,
            direction,
        };
    }

    function repositionFloaters() {
        conflictsOfInterest = new Map(conflictsOfInterest);
        menu = menu;
    }

    function getSourceByID(id: string) {
        return project.getSources()[parseInt(id.replace('source', ''))];
    }

    function handleKey(event: KeyboardEvent) {
        const key = event.key;
        const command = event.ctrlKey || event.metaKey;

        if (key === 'Escape') {
            layout = layout.withoutFullscreen();
            return;
        }
        if (key === '1' && command) {
            layout = layout.withArrangement(Arrangement.vertical);
            return;
        }
        if (key === '2' && command) {
            layout = layout.withArrangement(Arrangement.horizontal);
            return;
        }
        if (key === '3' && command) {
            layout = layout.withArrangement(Arrangement.free);
            return;
        }
        if (key === 'Enter' && command) {
            if (project.evaluator.isPlaying()) project.evaluator.pause();
            else project.evaluator.play();
            event.preventDefault();
            return;
        }

        // When in stepping mode, or when command is pressed
        if (!$playing || command) {
            if (key === 'Backspace') {
                // To start
                if (event.ctrlKey && event.shiftKey)
                    project.evaluator.stepTo(0);
                // To previous input
                else if (event.shiftKey) project.evaluator.stepBackToInput();
                // To previous step
                else project.evaluator.stepBackWithinProgram();
                event.preventDefault();
            } else if (key === ' ') {
                // To start
                if (event.ctrlKey && event.shiftKey)
                    project.evaluator.stepToEnd();
                // To previous input
                else if (event.shiftKey) project.evaluator.stepToInput();
                // To previous step
                else project.evaluator.stepWithinProgram();
                event.preventDefault();
            }
            return;
        }
    }

    function getMenuPosition(caret: Caret) {
        // Find the editor
        const editor = document.querySelector(
            `.editor[data-id="${caret.source.id}"]`
        );
        if (editor === null) return undefined;

        // Is it a node? Position near it's top left.
        if (caret.position instanceof Node) {
            const view = editor.querySelector(
                `.node-view[data-id="${caret.position.id}"]`
            );
            if (view == null) return undefined;
            const rect = view.getBoundingClientRect();
            return {
                left: rect.left,
                top: rect.bottom,
            };
        }
        // Is it a position? Position at the bottom right of the caret.
        else if (caret.isIndex()) {
            // Find the position of the caret in the editor.
            const view = editor.querySelector('.caret');
            if (view === null) return undefined;
            const rect = view.getBoundingClientRect();
            return {
                left: rect.left,
                top: rect.bottom,
            };
        }
    }

    function toggleTile(tile: Tile) {
        if (
            tile === layout.getPalette() &&
            $selectedOutput &&
            selectedOutputPaths
        ) {
            if (tile.mode === Mode.Collapsed && $selectedOutput.length === 0) {
                const output = project.getOutput();
                if (output.length > 0)
                    setSelectedOutput(selectedOutputPaths, project, [
                        output[0],
                    ]);
            } else if (tile.mode === Mode.Expanded) {
                setSelectedOutput(selectedOutputPaths, project, []);
            }
        }

        setMode(
            tile,
            tile.mode === Mode.Expanded ? Mode.Collapsed : Mode.Expanded
        );
    }

    function addSource() {
        $projects.revise(
            project,
            project.withNewSource(
                `${$preferredTranslations[0].terminology.source}${
                    project.supplements.length + 1
                }`
            )
        );
    }

    function removeSource(source: Source) {
        $projects.revise(project, project.withoutSource(source));
    }

    function renameSource(id: string, name: string) {
        if (!isName(name)) return;
        const source = getSourceByID(id);
        $projects.revise(
            project,
            project.withSource(
                source,
                source.withName(name, $preferredLanguages[0])
            )
        );
    }

    async function close() {
        goto('/project');
    }
</script>

<!-- Render the app header and the current project, if there is one. -->
<main
    class="project"
    tabIndex="0"
    on:keydown={handleKey}
    bind:this={view}
    transition:fade={getAnimationDuration()}
>
    {#if !layout.isFullscreen()}
        <section class="header" class:stepping={!$playing}>
            <Controls {project} />
            <Timeline evaluator={project.evaluator} />
        </section>
    {/if}

    <div
        class="canvas"
        on:mousedown={handleMouseDown}
        on:mouseup={handleMouseUp}
        on:mousemove={handleMouseMove}
        on:transitionend={repositionFloaters}
        on:scroll={repositionFloaters}
        bind:clientWidth={canvasWidth}
        bind:clientHeight={canvasHeight}
        bind:this={canvas}
    >
        <!-- This little guy enables the scroll bars to appear at the furthest extent a window has moved. -->
        {#if layout.arrangement === Arrangement.free}
            <div
                class="boundary"
                style:left="{maxRight}px"
                style:top="{maxBottom}px"
                style:position="absolute">&nbsp;</div
            >
        {/if}

        {#key tileIDSequence}
            {#each layout.tiles as tile (tile.id)}
                {#if tile.mode === Mode.Expanded && (layout.fullscreenID === undefined || layout.fullscreenID === tile.id)}
                    <TileView
                        {tile}
                        {layout}
                        arrangement={layout.arrangement}
                        background={tile.kind === Content.Output
                            ? outputBackground
                            : null}
                        dragging={draggedTile?.id === tile.id}
                        fullscreenID={layout.fullscreenID}
                        on:mode={(event) => setMode(tile, event.detail.mode)}
                        on:position={(event) =>
                            positionTile(tile, event.detail.position)}
                        on:resize={(event) =>
                            resizeTile(
                                event.detail.id,
                                event.detail.direction,
                                event.detail.left,
                                event.detail.top
                            )}
                        on:scroll={repositionFloaters}
                        on:rename={(event) =>
                            renameSource(event.detail.id, event.detail.name)}
                        on:fullscreen={(event) =>
                            setFullscreen(tile, event.detail.fullscreen)}
                    >
                        <svelte:fragment slot="extra">
                            {#if tile.kind === Content.Output}<Button
                                    tip={$preferredTranslations[0].ui.tooltip
                                        .grid}
                                    action={() => (grid = !grid)}>▦</Button
                                ><Button
                                    tip={$preferredTranslations[0].ui.tooltip
                                        .fit}
                                    action={() => (fit = !fit)}
                                    >{#if fit}🔒{:else}🔓{/if}</Button
                                >
                            {:else if tile.isSource()}
                                {@const source = getSourceByID(tile.id)}
                                {#if source !== project.main}
                                    <ConfirmButton
                                        tip={$preferredTranslations[0].ui
                                            .tooltip.removeSource}
                                        action={() => removeSource(source)}
                                        prompt={$preferredTranslations[0].ui
                                            .prompt.removeSource}
                                        >⨉</ConfirmButton
                                    >
                                {/if}
                            {/if}
                        </svelte:fragment>
                        <svelte:fragment slot="content">
                            {#if tile.kind === Content.Documentation}
                                <Documentation />
                            {:else if tile.kind === Content.Palette}
                                <Palette {project} />
                            {:else if tile.kind === Content.Output}
                                <OutputView
                                    {project}
                                    source={project.main}
                                    {latest}
                                    fullscreen={layout.fullscreenID === tile.id}
                                    bind:fit
                                    bind:grid
                                    mode={'peripheral'}
                                    bind:background={outputBackground}
                                />
                            {:else}
                                <Editor
                                    {project}
                                    source={getSourceByID(tile.id)}
                                    bind:menu
                                    on:conflicts={(event) =>
                                        (conflictsOfInterest =
                                            conflictsOfInterest.set(
                                                event.detail.source,
                                                event.detail.conflicts
                                            ))}
                                />
                            {/if}</svelte:fragment
                        ></TileView
                    >
                {/if}
            {/each}
        {/key}
    </div>

    {#if !layout.isFullscreen()}
        <section class="footer">
            <Status />
            <TextField
                placeholder={$preferredTranslations[0].ui.placeholders.project}
                fit
                text={project.name}
                border={false}
                changed={(name) =>
                    $projects.revise(project, project.withName(name))}
            />
            <Button
                tip={layout.arrangement === Arrangement.free
                    ? $preferredTranslations[0].ui.tooltip.vertical
                    : layout.arrangement === Arrangement.vertical
                    ? $preferredTranslations[0].ui.tooltip.horizontal
                    : $preferredTranslations[0].ui.tooltip.freeform}
                action={() =>
                    (layout = layout.withNextArrangement(
                        canvasWidth,
                        canvasHeight
                    ))}
                >{#if layout.arrangement === Arrangement.vertical}↕️{:else if layout.arrangement === Arrangement.horizontal}↔️{:else if layout.arrangement === Arrangement.free}█{/if}</Button
            >
            {#each layout.getNonSources() as tile}
                <NonSourceTileToggle
                    {tile}
                    on:toggle={() => toggleTile(tile)}
                />
            {/each}
            {#each project.getSources() as source, index}
                {@const tile = layout.getTileWithID(Layout.getSourceID(index))}
                {#if tile && tile.isCollapsed()}
                    <!-- Mini source view output is visible when collapsed, or if its main, when output is collapsed. -->
                    <MiniSourceView
                        {project}
                        {source}
                        output={source === project.main
                            ? layout.getOutput()?.mode === Mode.Collapsed
                            : tile.mode === Mode.Collapsed}
                        expanded={tile.mode === Mode.Expanded}
                        on:toggle={() => toggleTile(tile)}
                    />
                {/if}
            {/each}
            <Button
                tip={$preferredTranslations[0].ui.tooltip.addSource}
                action={addSource}>+</Button
            >

            <div class="settings">
                <Settings />
                <Button
                    tip={$preferredTranslations[0].ui.tooltip.close}
                    action={close}>❌</Button
                >
            </div>
        </section>

        <!-- Render annotations on top of the tiles and the footer -->
        <Annotations
            {project}
            conflicts={visibleConflicts}
            stepping={!$playing}
        />

        <!-- Render the menu on top of the annotations -->
        {#if menu && menuPosition}
            <Menu {menu} position={menuPosition} />
        {/if}

        <!-- Render the dragged node over the whole project -->
        {#if $dragged !== undefined}
            <!-- Render the highlight underneath the code -->
            <div class="drag-outline">
                {#if outline}<Highlight {...outline} above={false} />{/if}
            </div>
            <div
                class="drag-container dragging"
                style="left: {mouseX}px; top:{mouseY}px;"
                bind:this={dragContainer}
            >
                <RootView
                    node={$dragged.node}
                    spaces={project.getSourceOf($dragged.node)?.spaces}
                />
                <div class="cursor">🐲</div>
            </div>
        {/if}
    {/if}
</main>

<style>
    .project {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        background-color: var(--wordplay-background);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .project:focus:after {
        width: 100%;
        height: 100%;
        content: '';
        outline: var(--wordplay-highlight) solid var(--wordplay-focus-width);
        outline-offset: calc(-1 * var(--wordplay-focus-width));
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }

    .canvas {
        flex: 1;
        overflow: scroll;
    }

    .header {
        border-bottom: var(--wordplay-border-color) solid
            var(--wordplay-border-width);
        padding: var(--wordplay-spacing);
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: var(--wordplay-spacing);
    }

    .header.stepping {
        background-color: var(--wordplay-evaluation-color);
        color: var(--wordplay-background);
        border-bottom: none;
    }

    .footer {
        display: flex;
        flex-direction: row;
        align-items: center;
        flex-wrap: nowrap;
        padding: var(--wordplay-spacing);
        gap: var(--wordplay-spacing);
        border-top: var(--wordplay-border-width) solid
            var(--wordplay-border-color);
    }

    .settings {
        margin-left: auto;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: var(--wordplay-spacing);
    }

    .drag-outline {
        z-index: 2;
    }
    .drag-container {
        position: absolute;
        cursor: none;
        pointer-events: none;
        z-index: 2;
    }

    /* A fancy dragon cursor for dragon drop! Get it? */
    .cursor {
        position: absolute;
        font-size: 2rem;
        top: -1.5rem;
        left: -1.5rem;
        font-family: 'Noto Sans';
        pointer-events: none;
    }

    .drag-container :global(.token-view .text) {
        color: var(--wordplay-background);
    }
</style>
